
tokenbuiltin = {
	folders: {
		'Overlays': {
			tokens: {
				'Blood': {
					'data-img': 'https://drive.google.com/file/d/1frTuvq-64DA23ayC6P0XGZyo0M6paEID/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Big Bang': {
					'data-img': 'https://drive.google.com/file/d/19pbEuWVSQo15vmlsnJry-q3ordcAlaej/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Fire': {
					'data-img': 'https://drive.google.com/file/d/1_wE3B5rvr38cM9NMbCQ__WUf0RIXIuhQ/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Flame 1': {
					'data-img': 'https://thumbs.gfycat.com/GiddyMajorDingo-small.gif',
					'data-disableborder': true,
					'data-square': true,
				},
				'Flame 2': {
					'data-img': 'https://cutewallpaper.org/21/fire-gif-transparent-background/Fire-PNG-Gif-Transparent-Fire-GifPNG-Images-PlusPNG.gif',
					'data-disableborder': true,
					'data-square': true,
				},
				'Nebula': {
					'data-img': 'https://drive.google.com/file/d/1AeoKU444D3DrtjebegH0yRXNolrqw89K/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Web': {
					'data-img': 'https://drive.google.com/file/d/1rGuD7FMtzy6XR0qcsewndhS33wZL8vEM/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
			}
		},
		'Weapons': {
			tokens: {
				'Heartseeker Blade': {
					'data-img': 'https://drive.google.com/file/d/1Ft84c1VwnEhwKPew8Yyq8w8NFViC7Mr7/view?usp=sharing',
					'data-disablestat': true,
				}
			}
		},
	},
	tokens: {
		'Commoner': {
			'data-img': 'https://drive.google.com/file/d/1H-5cCt03oIB43CnhmdaHM6P2Aw8T2n60/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1H-5cCt03oIB43CnhmdaHM6P2Aw8T2n60/view?usp=sharing',
				'https://drive.google.com/file/d/14sNpLcJlzOfL4A5Qb_zdrYmOTZk51GTM/view?usp=sharing',
				'https://i.pinimg.com/564x/fa/93/fb/fa93fbf94a90d2068af62b5a34b48d2d.jpg',
				'https://i.pinimg.com/564x/b1/88/10/b18810e3a419fe6c9666ec64c67fdb4f.jpg',
				'https://i.pinimg.com/564x/b1/61/18/b16118b557ed8cd55a72631ff763fa97.jpg',
				'https://i.pinimg.com/564x/f7/6c/e5/f76ce511507ceb4be5003507c4b3190e.jpg',
				'https://i.pinimg.com/564x/d5/9b/e6/d59be622749ea74ccbc88485783e679c.jpg',
				'https://i.pinimg.com/564x/55/22/96/55229604ec385c8c1bf442a187a3aeeb.jpg',
				'https://i.pinimg.com/564x/da/56/f5/da56f50ba711df5b7c80e2fc240d9786.jpg',
				'https://i.pinimg.com/236x/62/45/8e/62458effd9b3901aa220954d50410988.jpg',
				'https://i.pinimg.com/236x/dc/39/e3/dc39e3e0edf1204d128565084146e221.jpg',
				'https://i.pinimg.com/236x/5a/13/5f/5a135f30617868eb35a78c0c268bd069.jpg',
				'https://i.pinimg.com/236x/6a/e2/51/6ae25147759cdf023dac43cdfeb68ef7.jpg',
				'https://i.pinimg.com/236x/d5/9b/e6/d59be622749ea74ccbc88485783e679c.jpg',
				'https://i.pinimg.com/236x/ec/24/81/ec2481a73c161cbbb70622e485bba1ae.jpg',
			]
		},
		'Dragonborn [F]': {
			'data-img': 'https://i.imgur.com/92aaNuq.png',
			'data-alternative-images': [
				'https://i.imgur.com/92aaNuq.png',
				'https://i.imgur.com/4WTK514.png',
				'https://i.imgur.com/vV4mfTo.png',
				'https://i.imgur.com/RdJKUBF.png',
			]
		},
		'Dragonborn [M]': {
			'data-img': 'https://i.imgur.com/0qQpdH6.png',
			'data-alternative-images': [
				'https://i.imgur.com/0qQpdH6.png',
				'https://i.imgur.com/EnMudqy.png',
				'https://i.imgur.com/ovnswTE.png',
				'https://i.imgur.com/29uuOXb.png',
				'https://i.imgur.com/Tjyc9Eq.png',
				'https://i.imgur.com/5k3RtNI.png',
				'https://i.imgur.com/YHOfDUc.png',
				'https://i.imgur.com/tQdEaQp.png',
				'https://i.imgur.com/bZZbhFd.png',
				'https://i.imgur.com/qpbahvt.png',
				'https://i.imgur.com/lSZIr0v.png',
				'https://i.imgur.com/Yxd8OuY.png',
				'https://i.imgur.com/Uha5043.png',
				'https://i.imgur.com/87kkYBT.png',
				'https://i.imgur.com/Mu4isFZ.png',
			]
		},
		'Drow [F]': {
			'data-img': 'https://i.imgur.com/lwPqseX.png',
			'data-alternative-images': [
				'https://i.imgur.com/lwPqseX.png',
				'https://i.imgur.com/cVaeAum.png',
				'https://i.imgur.com/2qHM12W.png',
				'https://i.imgur.com/apqxuLf.png',
				'https://i.imgur.com/OkdFTrq.png',
				'https://i.imgur.com/W4NtBsW.png',
				'https://i.imgur.com/yoIYDKO.png',
				'https://i.imgur.com/d4baR5O.png',
				'https://i.imgur.com/hpxtRYf.png',
				'https://i.imgur.com/SwxOZEX.png',
				'https://i.imgur.com/wGyXG6h.png',
				'https://i.imgur.com/ZolhnEc.png',
				'https://i.imgur.com/ROnLoAj.png',
				'https://i.imgur.com/PM09pdy.png',
				'https://i.imgur.com/6c8FF5q.png',
				'https://i.imgur.com/aqjKtH5.png',
				'https://i.imgur.com/v49Gd3r.png',
				'https://i.imgur.com/FHMszi4.png',
				'https://i.imgur.com/Lom5T9S.png',
			]
		},
		'Drow [M]': {
			'data-img': 'https://i.imgur.com/RgY5TkF.png',
			'data-alternative-images': [
				'https://i.imgur.com/RgY5TkF.png',
				'https://i.imgur.com/RsCAhou.png',
				'https://i.imgur.com/nwAzSyq.png',
				'https://i.imgur.com/aBlbyWo.png',
				'https://i.imgur.com/jEBw3ta.png',
				'https://i.imgur.com/oXyKmyK.png',
				'https://i.imgur.com/4BKZMqc.png',
				'https://i.imgur.com/8TcrJ88.png',
				'https://i.imgur.com/jCWJC1V.png',
				'https://i.imgur.com/WbWzpGq.png',
				'https://i.imgur.com/O6ui3WV.png',
				'https://i.imgur.com/Qr8TXfP.png',
				'https://i.imgur.com/9NuWJG6.png',
				'https://i.imgur.com/2LwVTUr.png',
			]
		},
		'Dwarf [F]': {
			'data-img': 'https://i.imgur.com/4Xuzbp6.png',
			'data-alternative-images': [
				'https://i.imgur.com/4Xuzbp6.png',
				'https://i.imgur.com/AmuvYtQ.png',
				'https://i.imgur.com/ZJvqWHQ.png',
				'https://i.imgur.com/eiWM0V7.png',
				'https://i.imgur.com/UED8IzA.png',
				'https://i.imgur.com/BwDRKyr.png',
			]
		},
		'Dwarf [M]': {
			'data-img': 'https://i.imgur.com/T6K1v8s.png',
			'data-alternative-images': [
				'https://i.imgur.com/T6K1v8s.png',
				'https://i.imgur.com/7xgLl17.png',
				'https://i.imgur.com/zO45eax.png',
				'https://i.imgur.com/w7KIJiI.png',
				'https://i.imgur.com/G9iZhpX.png',
				'https://i.imgur.com/F2hwQHB.png',
				'https://i.imgur.com/eamn3uD.png',
				'https://i.imgur.com/BSg4egK.png',
				'https://i.imgur.com/WRS4HKH.png',
				'https://i.imgur.com/G6aLVWI.png',
				'https://i.imgur.com/iSz72pl.png',
				'https://i.imgur.com/04X94ln.png',
				'https://i.imgur.com/F5kRG9O.png',
				'https://i.imgur.com/kANojx5.png',
				'https://i.imgur.com/SPQXGob.png',
				'https://i.imgur.com/jhVxT3w.png',
				'https://i.imgur.com/usObgvL.png',
				'https://i.imgur.com/4LUdLCx.png',
				'https://i.imgur.com/78ZtTUn.png',
			]
		},
		'Elf [F]': {
			'data-img': 'https://i.imgur.com/5brExHK.png',
			'data-alternative-images': [
				'https://i.imgur.com/5brExHK.png',
				'https://i.imgur.com/97Ssvg7.png',
				'https://i.imgur.com/Ql7WS0c.png',
				'https://i.imgur.com/vv4dBMN.png',
				'https://i.imgur.com/RBJ0P2K.png',
				'https://i.imgur.com/BVyZapA.png',
				'https://i.imgur.com/LyGbTHB.png',
				'https://i.imgur.com/MvxHbId.png',
				'https://i.imgur.com/S2taBOJ.png',
				'https://i.imgur.com/gbu9vUX.png',
				'https://i.imgur.com/6tSIQyq.png',
				'https://i.imgur.com/Y4d6rzn.png',
				'https://i.imgur.com/mo6XKpV.png',
				'https://i.imgur.com/RdTPLng.png',
				'https://i.imgur.com/CBwlgMF.png',
				'https://i.imgur.com/8n7IpwR.png',
				'https://i.imgur.com/rGbRzLw.png',
				'https://i.imgur.com/2Lglcip.png',
			]
		},
		'Elf [M]': {
			'data-img': 'https://i.imgur.com/KhyErAR.png',
			'data-alternative-images': [
				'https://i.imgur.com/KhyErAR.png',
				'https://i.imgur.com/bh9ZIeg.png',
				'https://i.imgur.com/K8U1b0h.png',
				'https://i.imgur.com/T3LBvjm.png',
				'https://i.imgur.com/06A68du.png',
				'https://i.imgur.com/DF1dSy7.png',
				'https://i.imgur.com/lG3wpol.png',
				'https://i.imgur.com/JC0VwYz.png',
				'https://i.imgur.com/iNaGb82.png',
				'https://i.imgur.com/w4rZdMx.png',
				'https://i.imgur.com/Eagxsqn.png',
				'https://i.imgur.com/PN7rm5K.png',
				'https://i.imgur.com/vkEGS5t.png',
				'https://i.imgur.com/5cUJo1X.png',
				'https://i.imgur.com/36nKnjL.png',
				'https://i.imgur.com/zzVxVGA.png',
				'https://i.imgur.com/f24uQF7.png',
				'https://i.imgur.com/2d2apvN.png',
				'https://i.imgur.com/ukdo8ds.png',
				'https://i.imgur.com/F9r9k3P.png',
				'https://i.imgur.com/dH30PNn.png',
				'https://i.imgur.com/9zg0eK8.png',
				'https://i.imgur.com/xQ0uII4.png',
				'https://i.imgur.com/Yt6osn6.png',
				'https://i.imgur.com/bNdE7DR.png',
				'https://i.imgur.com/AF3fv3C.png',
				'https://i.imgur.com/j3aX15i.png',
				'https://i.imgur.com/X1GP2WM.png',
				'https://i.imgur.com/v5FHlGi.png',
				'https://i.imgur.com/LfbJzvb.png',
				'https://i.imgur.com/V0rwmIX.png',
				'https://i.imgur.com/hqSP2Rs.png',
				'https://i.imgur.com/MNUuxZj.png',
				'https://i.imgur.com/dl8Vf71.png',
				'https://i.imgur.com/wSofg8Z.png',
				'https://i.imgur.com/mxXCnY1.png',
				'https://i.imgur.com/uwQOjqz.png',
				'https://i.imgur.com/d8FvdaA.png',
				'https://i.imgur.com/b3n8zEv.png',
				'https://i.imgur.com/aiHUW1S.png',
				'https://i.imgur.com/685hEZP.png',
				'https://i.imgur.com/bO5teIc.png',
				'https://i.imgur.com/4sbNTs1.png',
				'https://i.imgur.com/x5PsGUD.png',
			]
		},
		'Genasi': {
			'data-img': 'https://i.imgur.com/YnlG0US.png',
			'data-alternative-images': [
				'https://i.imgur.com/YnlG0US.png',
				'https://i.imgur.com/6TrSNc8.png',
				'https://i.imgur.com/VFn3KwT.png',
				'https://i.imgur.com/B1pH2vd.png',
				'https://i.imgur.com/m9HfCRo.png',
				'https://i.imgur.com/LN9r5Qq.png',
			]
		},
		'Guard [M]': {
			'data-img': 'https://drive.google.com/file/d/1C9ghQrfHckKPOMEHdmStaN47y0OXUPZ9/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1C9ghQrfHckKPOMEHdmStaN47y0OXUPZ9/view?usp=sharing'
			]
		},
		'Human [F]': {
			'data-img': 'https://i.imgur.com/NjP2sGL.png',
			'data-alternative-images': [
				'https://i.imgur.com/NjP2sGL.png',
				'https://i.imgur.com/H8Q36Zh.png',
				'https://i.imgur.com/RZq8SBK.png',
				'https://i.imgur.com/HHwopfD.png',
				'https://i.imgur.com/XqxVZmK.png',
				'https://i.imgur.com/CPAfuWB.png',
				'https://i.imgur.com/74bpcvT.png',
				'https://i.imgur.com/urg9Qhh.png',
				'https://i.imgur.com/t4yQcY9.png',
				'https://i.imgur.com/eymbYs8.png',
				'https://i.imgur.com/HOgBuYA.png',
				'https://i.imgur.com/FofhAaY.png',
				'https://i.imgur.com/ftlyRz6.png',
				'https://i.imgur.com/ufdYpaw.png',
				'https://i.imgur.com/PZ0UHJV.png',
				'https://i.imgur.com/6Ha5aDY.png',
				'https://i.imgur.com/DOnKbPL.png',
				'https://i.imgur.com/lbxFV6I.png',
				'https://i.imgur.com/2U9nwqu.png',
				'https://i.imgur.com/KcIaDqG.png',
				'https://i.imgur.com/NDNovgG.png',
				'https://i.imgur.com/RZkpx3l.png',
				'https://i.imgur.com/fZKrYaJ.png',
				'https://i.imgur.com/AuXrxtN.png',
				'https://i.imgur.com/tG53u3r.png',
				'https://i.imgur.com/9emKSJI.png',
			]
		},
		'Human [M]': {
			'data-img': 'https://i.imgur.com/vyeBFvg.png',
			'data-alternative-images': [
				'https://i.imgur.com/vyeBFvg.png',
				'https://i.imgur.com/iicVOSh.png',
				'https://i.imgur.com/RXQvDzB.png',
				'https://i.imgur.com/yMm3znX.png',
				'https://i.imgur.com/ZLYlstS.png',
				'https://i.imgur.com/E4aNjka.png',
				'https://i.imgur.com/sJodY4T.png',
				'https://i.imgur.com/cfsFqZk.png',
				'https://i.imgur.com/XdXU7mn.png',
				'https://i.imgur.com/GcNRFqx.png',
				'https://i.imgur.com/zVfhSCK.png',
				'https://i.imgur.com/0Hz1O3A.png',
				'https://i.imgur.com/nEh1ufo.png',
				'https://i.imgur.com/6XEUaP5.png',
				'https://i.imgur.com/VSU5NHE.png',
				'https://i.imgur.com/rYyd1h2.png',
				'https://i.imgur.com/07ffel4.png',
				'https://i.imgur.com/pyXlYqe.png',
				'https://i.imgur.com/KS2Hybd.png',
				'https://i.imgur.com/T6v1q7T.png',
				'https://i.imgur.com/juJzfQr.png',
				'https://i.imgur.com/RGzc7aD.png',
				'https://i.imgur.com/9J2iKvp.png',
				'https://i.imgur.com/2SaSS0Y.png',
				'https://i.imgur.com/jJ4c6ba.png',
				'https://i.imgur.com/k7Wx4mJ.png',
				'https://i.imgur.com/Vo1U9cK.png',
				'https://i.imgur.com/LVWkKVI.png',
				'https://i.imgur.com/yMMA82P.png',
				'https://i.imgur.com/f0N2oJa.png',
				'https://i.imgur.com/XJR4m0s.png',
				'https://i.imgur.com/8BKKghq.png',
				'https://i.imgur.com/FBPr0Qx.png',
				'https://i.imgur.com/zPJVZV9.png',
				'https://i.imgur.com/Fxnv4ze.png',
				'https://i.imgur.com/D3MfkZH.png',
				'https://i.imgur.com/fXa8rTq.png',
				'https://i.imgur.com/azyGhw3.png',
				'https://i.imgur.com/QmmV63Y.png',
				'https://i.imgur.com/r84pZVU.png',
				'https://i.imgur.com/qQKIKnR.png',
				'https://i.imgur.com/cDq8Vsr.png',
				'https://i.imgur.com/CbANiCZ.png',
				'https://i.imgur.com/roOhEoe.png',
				'https://i.imgur.com/2cLWc3p.png',
				'https://i.imgur.com/BgvoUWh.png',
				'https://i.imgur.com/PXEx15g.png',
				'https://i.imgur.com/GlG30ko.png',
				'https://i.imgur.com/MilamyO.png',
				'https://i.imgur.com/fnmpif1.png',
				'https://i.imgur.com/LxSkBCv.png',
				'https://i.imgur.com/BDWVEoG.png',
				'https://i.imgur.com/H8gIrL2.png',
				'https://i.imgur.com/Kz31l7I.png',
				'https://i.imgur.com/URuYHUf.png',
				'https://i.imgur.com/jpYQQCi.png',
				'https://i.imgur.com/onBgm22.png',
				'https://i.imgur.com/s86MIgN.png',
				'https://i.imgur.com/AW2altj.png',
				'https://i.imgur.com/gGag3hL.png',
				'https://i.imgur.com/C184k7z.png',
				'https://i.imgur.com/Q2EL6Zo.png',
				'https://i.imgur.com/AqOra0V.png',
				'https://i.imgur.com/NRowLmi.png',
				'https://i.imgur.com/47levai.png',
				'https://i.imgur.com/yDhhssO.png',
				'https://i.imgur.com/1J3nNHm.png',
				'https://i.imgur.com/S1uJBLa.png',
				'https://i.imgur.com/QT918eT.png',
				'https://i.imgur.com/FFLNXSA.png',
				'https://i.imgur.com/98mmYIW.png',
				'https://i.imgur.com/xi7maaE.png',
				'https://i.imgur.com/XBzgh8w.png',
				'https://i.imgur.com/pFW96Y2.png',
				'https://i.imgur.com/d1Cnrja.png',
				'https://i.imgur.com/fHSoonu.png',
				'https://i.imgur.com/UltpGWb.png',
				'https://i.imgur.com/wRUadat.png',
				'https://i.imgur.com/MvMSm3r.png',
				'https://i.imgur.com/eMfk7Zx.png',
				'https://i.imgur.com/yMNo6I9.png',
				'https://i.imgur.com/qjGsNn7.png',
				'https://i.imgur.com/JnJiGoa.png',
				'https://i.imgur.com/ZTSWn3Y.png',
				'https://i.imgur.com/v4F4gjg.png',
				'https://i.imgur.com/gJ9XBJI.png',
				'https://i.imgur.com/D7tMAL2.png',
				'https://i.imgur.com/hEQxRZy.png',
				'https://i.imgur.com/4RZiadV.png',
				'https://i.imgur.com/NYZJ8xP.png',
				'https://i.imgur.com/alANUDw.png',
				'https://i.imgur.com/3pxBGbD.png',
				'https://i.imgur.com/DHfRth2.png',
				'https://i.imgur.com/1bX4Qln.png',
				'https://i.imgur.com/0rzf1SN.png',
				'https://i.imgur.com/DFP9CIA.png',
				'https://i.imgur.com/fBh4m9C.png',
				'https://i.imgur.com/JqhtEZ0.png',
				'https://i.imgur.com/6l2RDlv.png',
				'https://i.imgur.com/FZmdqsr.png',
			]
		},
		'Maid [F]': {
			'data-img': 'https://drive.google.com/file/d/1wB5yKNKQ5dqkLhvWA5UZybLBBTDu-57c/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1wB5yKNKQ5dqkLhvWA5UZybLBBTDu-57c/view?usp=sharing'
			]
		},
		'Orc [F]': {
			'data-img': 'https://i.imgur.com/gmUUKun.png',
			'data-alternative-images': [
				'https://i.imgur.com/gmUUKun.png',
				'https://i.imgur.com/L0lLPWH.png',
				'https://i.imgur.com/Pwpr4Lp.png',
				'https://i.imgur.com/Zz9cnLt.png',
			]
		},
		'Orc [M]': {
			'data-img': 'https://i.imgur.com/4pWxSUn.png',
			'data-alternative-images': [
				'https://i.imgur.com/4pWxSUn.png',
				'https://i.imgur.com/OCrXvMz.png',
				'https://i.imgur.com/DcDsPj1.png',
				'https://i.imgur.com/mSZB6Xi.png',
				'https://i.imgur.com/BjgMrNq.png',
				'https://i.imgur.com/PSoXLYT.png',
				'https://i.imgur.com/W27Ad8q.png',
				'https://i.imgur.com/NChSGAp.png',
				'https://i.imgur.com/l3AOJfN.png',
				'https://i.imgur.com/sKQLsz5.png',
				'https://i.imgur.com/i1taIwb.png',
			]
		},
		'Tiefling [F]': {
			'data-img': 'https://i.imgur.com/r6fKPlI.png',
			'data-alternative-images': [
				'https://i.imgur.com/r6fKPlI.png',
				'https://i.imgur.com/gbs56aT.png',
				'https://i.imgur.com/LL8SD3k.png',
				'https://i.imgur.com/7gBPY82.png',
				'https://i.imgur.com/YjAMYM1.png',
				'https://i.imgur.com/dP9wszv.png',
				'https://i.imgur.com/HtsCPgu.png',
				'https://i.imgur.com/n2nb2NL.png',
				'https://i.imgur.com/STNSgme.png',
				'https://i.imgur.com/4iZmAAl.png',
				'https://i.imgur.com/LcPOA39.png',
				'https://i.imgur.com/xDTDx7I.png',
				'https://i.imgur.com/PyecEQG.png',
				'https://i.imgur.com/jRK8fZ6.png',
				'https://i.imgur.com/gPK3Qz7.png',
				'https://i.imgur.com/XwKL0NN.png',
				'https://i.imgur.com/rYc2U8J.png',
				'https://i.imgur.com/jHI0pdZ.png',
			]
		},
		'Tiefling [M]': {
			'data-img': 'https://i.imgur.com/iLKRQF5.png',
			'data-alternative-images': [
				'https://i.imgur.com/iLKRQF5.png',
				'https://i.imgur.com/H6EYE4b.png',
				'https://i.imgur.com/0lzHtWi.png',
				'https://i.imgur.com/6zcM3U9.png',
				'https://i.imgur.com/vLPCfzf.png',
				'https://i.imgur.com/pwuN7KB.png',
				'https://i.imgur.com/8GsL6N4.png',
				'https://i.imgur.com/YKFLCMO.png',
				'https://i.imgur.com/J5FescQ.png',
				'https://i.imgur.com/LHbk4bR.png',
				'https://i.imgur.com/YGs9gP0.png',
			]
		},
		'Warforged': {
			'data-img': 'https://i.imgur.com/N5Nvgkw.png',
			'data-alternative-images': [
				'https://i.imgur.com/N5Nvgkw.png',
				'https://i.imgur.com/8K3HZZJ.png',
				'https://i.imgur.com/KrYnmri.png',
				'https://i.imgur.com/JtyrFHx.png',
				'https://i.imgur.com/ApJMypw.png',
				'https://i.imgur.com/2p3WTci.png',
				'https://i.imgur.com/309BYqb.png',
				'https://i.imgur.com/r7my3b6.png',
				'https://i.imgur.com/SVo3VpB.png',
				'https://i.imgur.com/zrN3Vnt.png',
				'https://i.imgur.com/eKfE1AV.png',
			]
		}
	}
};


tokendata={
	folders:{},
};


function init_tokenmenu(){
	
	
	if(localStorage.getItem('CustomTokens') != null){
		tokendata=$.parseJSON(localStorage.getItem('CustomTokens'));
	}
	tokendata.folders['AboveVTT BUILTIN']=tokenbuiltin;

	let header = tokensPanel.header;
	header.append("<div class='panel-warning'>WARNING/WORKINPROGRESS. THIS TOKEN LIBRARY IS CURRENTLY STORED IN YOUR BROWSER STORAGE. IF YOU DELETE YOUR HISTORY YOU LOOSE YOUR LIBRARY</div>");
	
	let backButton = $(`<div class="tokens-panel-back-button"><div>Back</div></div>`);
	header.append(backButton);
	backButton.click(function(event) {
		let previous = containing_folder_path(window.CURRENT_TOKEN_PATH);
		fill_tokenmenu(previous);
	});
	
	fill_tokenmenu("");

	let addTokenButton = $(`<button id="add-token-btn" class="sidebar-panel-footer-button">Add Token</button>`);
	addTokenButton.click(function(event) {
		let path = $(event.target).attr("data-folder-path");
		if (path === undefined) {
			path = "";
		}
		display_custom_token_form(path);
	});
	let addFolderButton = $(`<button id="add-folder-btn" class="sidebar-panel-footer-button">Add Folder</button>`);
	addFolderButton.click(function(event) {
		var newfoldername = prompt("Enter the name of the new folder");
		if (newfoldername == undefined || newfoldername == "") {
			// don't add folders when cancel is pressed or if they didn't enter a folder name at all
			return;
		}
		let path = window.CURRENT_TOKEN_PATH;
		if (path === undefined) {
			path = "";
		}
		let folder = convert_path(path);
		if(!folder.folders) {
			folder.folders = {};
		}
		folder.folders[newfoldername] = {};
		persist_customtokens();
		fill_tokenmenu(`${path}/${newfoldername}`);
	});

	let buttonWrapper = $(`<div class="sidebar-panel-footer-horizontal-wrapper"></div>`)
	buttonWrapper.append(addTokenButton);
	buttonWrapper.append(addFolderButton);
	tokensPanel.footer.append(buttonWrapper);

	register_token_row_context_menu();             // context menu for each row
	register_custom_monster_image_context_menu();  // context menu for images within the customization modal
}

function convert_path(path){
	var pieces=path.split("/");
	var current=tokendata;
	
	for(var i=0;i<pieces.length;i++){
		if(pieces[i]=="")
			continue;
		current=current.folders[pieces[i]];
	}
	return current;
}

function fill_tokenmenu(path){
	console.log(`fill_tokenmenu ${path}`);
	if (path === undefined) {
		path = "";
	}
	window.CURRENT_TOKEN_PATH = path; // be careful using this. It should only be used for folder navigation
	let folder = convert_path(path);
	// $("#tokens-panel-data").empty();
	tokensPanel.body.empty();
	let footer = tokensPanel.footer;
	// TODO: consider storing current path on the tokensPanel object
	footer.find("#add-token-btn").attr("data-folder-path", path);
	footer.find("#add-token-btn").attr("data-folder-path", path);
	if (path == "") {
		tokensPanel.header.find(".tokens-panel-back-button").hide();
	} else {
		tokensPanel.header.find(".tokens-panel-back-button").show();
	}

	draw_custom_token_list(folder, path);
	
	if (is_builtin(path)) {
		// don't allow users to add tokens or folders inside the builtin folder
		tokensPanel.footer.hide();
	} else {
		tokensPanel.footer.show();
	}
}

function persist_customtokens(){
	tokendata.folders["AboveVTT BUILTIN"]={};
	localStorage.setItem("CustomTokens",JSON.stringify(tokendata));
	tokendata.folders["AboveVTT BUILTIN"]=tokenbuiltin;
}

function draw_custom_token_list(folder, path) {

	let list = $(`<div class="custom-token-list"></div>`);
	if (folder.folders) {
		for(let f in folder.folders) {
			let row = build_custom_token_row(f, window.EXTENSION_PATH + "assets/folder.svg", undefined, false);
			row.find(".custom-token-image-row-handle").remove(); // no drag handle on the right side of folders
			row.find(".custom-token-image-row-add svg").css("fill", "#fff");
			row.find(".custom-token-image-row-add").css("border", "#fff");
			row.find(".custom-token-image-row-add").prop("disabled", true);
			let currentFolderPath = path + "/" + f;
			row.click(function () {
				fill_tokenmenu(currentFolderPath);
			});
			row.attr('data-folder-name', f);
			row.attr('data-folder-path', path);
			list.append(row);
		}
	}

	if (folder.tokens) {
		for(let t in folder.tokens) {
			let token = folder.tokens[t]
			let name = token["data-name"];
			if (name == undefined) {
				name = t;
			}
			let imgSrc = token["data-img"];
			let tokenSize = token["data-token-size"];
			let subtitleText = "Small / Medium (5ft)";
			if (tokenSize != undefined) {
				switch (tokenSize) {
					case "custom": 
						subtitleText = "Custom (Xft)"; // figure this out
						break; 
					case 2: subtitleText = "Large (10ft)"; break;
					case 3: subtitleText = "Huge (15ft)"; break;
					case 4: subtitleText = "Gargantuan (20ft)"; break;
				}
			}
			let row = build_custom_token_row(name, imgSrc, subtitleText);
			for(prop in token){
				row.find(".custom-token-image-row-add").attr(prop, token[prop]);
			}
			row.find(".custom-token-image-row-add").attr("data-disablestat", true);
			row.find(".custom-token-image-row-add").attr("data-token-size", tokenSize);
			row.find(".custom-token-image-row-add").attr('data-tokendatapath', path);
			row.find(".custom-token-image-row-add").attr('data-tokendataname', t);
			row.find(".custom-token-image-row-add").click(function(event) {
				place_token_from_modal(path, t, window.TOKEN_SETTINGS["hidden"]);
			});
	
			row.attr('data-tokendatapath', path);
			row.attr('data-tokendataname', t);
			row.find(".custom-token-image-row-handle").click(function() {
				display_custom_token_form(path, t, token);
			});
	
			list.append(row);
		}
	}

	let body = tokensPanel.body;
	body.empty();
	body.append(list);
}

function build_custom_token_row(name, imgSrc, subtitleText, enableDrag = true) {

	let row = $(`<div class="custom-token-image-row"></div>`);
	let rowItem = $(`<div class="custom-token-image-row-item"></div>`);
	row.append(rowItem);

	let imgHolder = $(`<div class="custom-token-image-row-img"></div>`);
	let img = $(`<img src="${parse_img(imgSrc)}" />`);
	imgHolder.append(img);

	let details = $(`<div class="custom-token-image-row-details"></div>`);
	let title = $(`<div class="custom-token-image-row-details-title">${name}</div>`);
	details.append(title);
	if (subtitleText != undefined) {
		let subtitle = $(`<div class="custom-token-image-row-details-subtitle">${subtitleText}</div>`);
		details.append(subtitle);
	}

	let addButton = $(`
		<button class="custom-token-image-row-add" title="${name}" data-name="${name}" data-img="${imgSrc}">
			<svg viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.2 10.8V18h3.6v-7.2H18V7.2h-7.2V0H7.2v7.2H0v3.6h7.2z"></path></svg>
		</button>
	`);
	let handle = $(`
		<div class="custom-token-image-row-handle">
			<img src="${window.EXTENSION_PATH}assets/icons/cog.svg" style="width:100%;height:100%;" />
		</div>	
	`);

	rowItem.append(imgHolder);
	rowItem.append(details);
	rowItem.append(addButton);
	rowItem.append(handle);

	if (enableDrag) {
		rowItem.draggable({
			appendTo: "#VTTWRAPPER",
			zIndex: 100000,
			cursorAt: {top: 0, left: 0},
			cancel: '.custom-token-image-row-handle',
			helper: function(event) {
				let helper = $(event.currentTarget).find(".custom-token-image-row-img img").clone();
				let addButton = $(event.currentTarget).find(".custom-token-image-row-add");
				let path = addButton.attr("data-tokendatapath");
				let name = addButton.attr("data-tokendataname");
				helper.attr("src", random_image_for_token(path, name));
				return helper;
			},
			start: function (event, ui) {
				console.log("row-item drag start");
				let addButton = $(event.currentTarget).find(".custom-token-image-row-add");
				let tokenSize = addButton.data('token-size');
				if (tokenSize === undefined) {
					tokenSize = 1;
				}
				let width = Math.round(window.CURRENT_SCENE_DATA.hpps) * tokenSize;
				let helperWidth = width / (1.0 / window.ZOOM);
				$(ui.helper).css('width', `${helperWidth}px`);
				$(this).draggable('instance').offset.click = {
					left: Math.floor(ui.helper.width() / 2),
					top: Math.floor(ui.helper.height() / 2)
				};
			},
			stop: function (event, ui) { 
				// place a token where this was dropped
				console.log("row-item drag stop");
				let src = $(ui.helper).attr("src");
				let addButton = $(event.target).find(".custom-token-image-row-add");
				let path = addButton.attr("data-tokendatapath");
				let name = addButton.attr("data-tokendataname");
				let hidden = event.shiftKey || window.TOKEN_SETTINGS["hidden"];
				place_token_from_modal(path, name, hidden, src, event.pageX, event.pageY);
			}
		});
	}
	return row;
}


function register_token_row_context_menu() {

	// don't allow the context menu when right clicking on the add button since that adds a hidden token
	$(".custom-token-image-row").on("contextmenu", ".custom-token-image-row-add", function(event) {
		event.preventDefault();
		event.stopPropagation();
		let tokendatapath = $(event.currentTarget).attr("data-tokendatapath");
		let tokendataname = $(event.currentTarget).attr("data-tokendataname");
		if (tokendataname === undefined) {
			tokendataname = $(event.currentTarget).attr("data-name");
		}
		place_token_from_modal(tokendatapath, tokendataname, true);
	});

	$.contextMenu({
		selector: ".custom-token-image-row",
		build: function(element, e) {

			let items = {};
			
			let folderName = $(element).attr("data-folder-name");
			let isFolder = folderName !== undefined;
			
			let tokenAddButton = $(element).find(".custom-token-image-row-add");

			let path = "";
			if (isFolder) {
				path = $(element).attr("data-folder-path");
			} else {
				path = tokenAddButton.attr("data-tokendatapath");
			}
			if (path === undefined) {
				path = "";
			}
			let folder = convert_path(path);

			let tokenName = tokenAddButton.attr("data-tokendataname");
			if (tokenName === undefined) {
				tokenName = tokenAddButton.attr("data-name");
			}
			
			if (!isFolder) {
				// add token items

				items["place"] = {
					name: "Place Token",
					callback: function(itemKey, opt, originalEvent) {
						place_token_from_modal(path, tokenName, false);
					}
				};
				
				items["placeHidden"] = {
					name: "Place Hidden Token",
					callback: function(itemKey, opt, originalEvent) {
						place_token_from_modal(path, tokenName, true);
					}
				};

				items["copyUrl"] = {
					name: "Copy Url",
					callback: function(itemKey, opt, originalEvent) {
						let imgSrc = tokenAddButton.attr("data-img");
						copy_to_clipboard(imgSrc);
					}
				};

			} 

			// add delete menu option
			if (path.startsWith("/AboveVTT BUILTIN")) {
				items["no-delete"] = {
					name: "Folders and Tokens provided by AboveVTT cannot be edited or deleted",
					disabled: true
				};
			} else {

				items["edit"] = {
					name: "Edit",
					callback: function(itemKey, opt, originalEvent) {
						if (isFolder) {
							var newfoldername = prompt("Enter the name of the folder", folderName);
							if (newfoldername != undefined && newfoldername.length > 0) {
								if(!folder.folders) {
									folder.folders = {};
								}
								folder.folders[newfoldername] = folder.folders[folderName];
								delete folder.folders[folderName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						} else {
							display_custom_token_form(path, tokenName);
						}
					}
				};
	
				items["border"] = "---";
	
				// not a built in folder or token, add an option to delete
				items["delete"] = {
					name: "Delete",
					callback: function(itemKey, opt, originalEvent) {
						if (isFolder) {
							console.log(`delete selected; folderName = ${folderName}`);
							if (confirm(`Are you sure you want to delete the folder "${folderName}"? The folder and all tokens in it will be deleted. This cannot be undone.`)) {
								delete folder.folders[folderName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						} else {
							console.log(`delete selected; tokenName = ${tokenName}`);
							if (confirm(`Are you sure you want to delete the token "${tokenName}"? This cannot be undone.`)) {
								delete folder.tokens[tokenName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						}
					}
				};
			}
			return { items: items };
		}
	});
}

function is_builtin(path) {
	if (path === undefined) {
		console.warn("is_builtin was called without a path");
		return false;
	}
	return path.startsWith("/AboveVTT BUILTIN");
}

function display_custom_token_form(path, name, token) {

	// close any that are already open. This shouldn't be necessary, but it doesn't hurt just in case
	close_sidebar_modal();

	if (path === undefined) {
		console.warn("display_custom_token_form was called without a path");
		path = "";
	}
	let folder = convert_path(path);

	if (name !== undefined && token === undefined) {
		// we got a name, but not a token. Let's see if we can find a token that matches the name
		token = folder.tokens[name];
	}

	let sidebarPanel = new SidebarPanel("custom-token-customization-modal");
	display_sidebar_modal(sidebarPanel);

	let explanationText = "Enter a url at the bottom to create a new token.";
	let headerTitle = name === undefined ? "New Token" : name
	sidebarPanel.updateHeader(headerTitle, "", explanationText);

	if (token !== undefined) {
		explanationText = "When placing tokens, one of these images will be chosen at random. Right-click an image for more options.";
		migrate_token_image_data(token);
	}

	// add all of the tokens images to the body
	redraw_images_in_modal_body(sidebarPanel.body, path, name, token);

	if (!is_builtin(path)) {
		// only build the footer for custom tokens. Don't allow builtin tokens to be edited
		build_custom_token_form_footer(sidebarPanel, path, name, token)
	}

	update_modal_images(sidebarPanel, populate_token_from_form(sidebarPanel, token));
}

function build_token_size_input(currentTokenSize, changeHandler) {
	let sizeNumber = parseInt(currentTokenSize); // 0, 1, 2, 3, 4, 5, etc
	if (isNaN(sizeNumber)) {
		sizeNumber = 1;
	}

	let upsq = window.CURRENT_SCENE_DATA.upsq;
	if (upsq === undefined || upsq.length == 0) {
		upsq = "ft";
	}

	let customStyle = sizeNumber > 4 ? "display:flex;" : "display:none;"

	let output = $(`
		<div class="token-image-modal-footer-select-wrapper">
			<div class="token-image-modal-footer-title">Token Size</div>
			<select name="data-token-size">
				<option value="0">Tiny (2.5${upsq})</option>
				<option value="1">Small/Medium (5${upsq})</option>
				<option value="2">Large (10${upsq})</option>
				<option value="3">Huge (15${upsq})</option>
				<option value="4">Gargantuan (20${upsq})</option>
				<option value="custom">Custom</option>
			</select>
		</div>
		<div class="token-image-modal-footer-select-wrapper" style="${customStyle}">
			<div class="token-image-modal-footer-title">Number Of Squares</div>
			<input type="text" name="data-token-size-custom" placeholder="5" style="width: 3rem;">
		</div>
	`);

	let tokenSizeInput = output.find("select");
	let customSizeInput = output.find("input");
	if (sizeNumber > 4) {
		tokenSizeInput.val("custom");
		customSizeInput.val(`${sizeNumber}`);
	} else {
		tokenSizeInput.val(`${sizeNumber}`);
	}

	tokenSizeInput.change(function(changeEvent) {
		let selectInput = $(changeEvent.target);
		let newValue = selectInput.val();
		let customInputWrapper = selectInput.parent().next();
		console.log("tokenSizeInput changed");
		if (newValue == "custom") {
			customInputWrapper.show();
		} else {
			customInputWrapper.hide();
			changeHandler(parseInt(newValue));
		}
	});

	customSizeInput.change(function(changeEvent) {
		console.log("customSizeInput changed");
		let textInput = $(changeEvent.target);
		let numberOfSquares = parseInt(textInput.val());
		if (!isNaN(numberOfSquares)) {
			changeHandler(numberOfSquares);
		}
	});	

	return output;
}

function build_custom_token_form_footer(sidebarPanel, path, name, token) {
	let footerText = token == undefined ? "Enter an Image Url" : "Add More Custom Images";
	const footerSubmit = function(imgUrl) {
		submit_custom_token_form(sidebarPanel, path);
	}

	let imageUrlInput = sidebarPanel.build_image_url_input(footerText, footerSubmit);

	let inputWrapper = sidebarPanel.inputWrapper;
	inputWrapper.append(imageUrlInput);

	let nameInput = $(`<input data-previous-name="${name}" title="token name" placeholder="my token name" name="addCustomName" type="text" style="width:100%" value="${name == undefined ? '' : name}" />`);
	nameInput.on('keyup', function(event) {
		if (event.key == "Enter") {
			submit_custom_token_form(sidebarPanel, path);
		}
	});

	let currentTokenSize = token == undefined ? undefined : token["data-token-size"];
	let tokenSizeInput = build_token_size_input(currentTokenSize, function(newTokenSize) {
		console.log(`tokenSizeInput onChange ${newTokenSize}`);
		submit_custom_token_form(sidebarPanel, path);
	});

	let tokenTypeInput = $(`
		<select name="data-square">
			<option value="default">Default</option>
			<option value="round">Round</option>
			<option value="square">Square</option>
		</select>
	`);
	// this is explicitly looking for 
	let tokenType = token == undefined ? undefined : token["data-square"];
	// this is explicitly looking for true/false because the default value is undefined
	if (tokenType == true) {
		tokenTypeInput.val("square");
	} else if (tokenType == false) {
		tokenTypeInput.val("round");
	} else {
		tokenTypeInput.val("default");
	}

	let hideBorderInput = $(`
		<select name="data-disableborder">
			<option value="default">Default</option>
			<option value="enabled">Border</option>
			<option value="disabled">No Border</option>
		</select>
	`);
	let hideBorder = token == undefined ? undefined : token["data-disableborder"];
	// this is explicitly looking for true/false because the default value is undefined
	if (hideBorder == true) {
		hideBorderInput.val("disabled");
	} else if (hideBorder == false) {
		hideBorderInput.val("enabled");
	} else {
		hideBorderInput.val("default");
	}

	let aspectRatioInput = $(`
		<select name="data-legacyaspectratio">
			<option value="default">Default</option>
			<option value="maintain">Maintain</option>
			<option value="legacy">Stretch</option>
		</select>
	`);
	let legacyaspectratio = token == undefined ? undefined : token["data-legacyaspectratio"];
	// this is explicitly looking for true/false because the default value is undefined
	if (legacyaspectratio == true) {
		aspectRatioInput.val("legacy");
	} else if (legacyaspectratio == false) {
		aspectRatioInput.val("maintain");
	} else {
		aspectRatioInput.val("default");
	}

	let saveButton = $(`<button class="sidebar-panel-footer-button" style="width:100%;padding:8px;margin-top:8px;margin-left:0px;">Save Token</button>`);
	saveButton.click(function(event) {
		submit_custom_token_form(sidebarPanel, path);
		close_sidebar_modal();
	});

	const onChange = function() {
		submit_custom_token_form(sidebarPanel, path);
	}
	tokenTypeInput.change(onChange);
	hideBorderInput.change(onChange);
	aspectRatioInput.change(onChange);

	inputWrapper.append($(`<div class="token-image-modal-footer-title" style="width:100%;padding-left:0px">Token Name</div>`));
	inputWrapper.append(nameInput);
	inputWrapper.append(tokenSizeInput);
	inputWrapper.append(`<div class="sidebar-panel-header-explanation" style="padding-bottom:6px;">The following will override global settings for this token. Global settings can be changed in the settings tab.</div>`)
	inputWrapper.append(build_select_input("Token Shape", tokenTypeInput));        // adds class token-round
	inputWrapper.append(build_select_input("Border Visibility", hideBorderInput)); // sets border-width: 4
	inputWrapper.append(build_select_input("Aspect Ratio", aspectRatioInput));     // adds class preserve-aspect-ratio
	inputWrapper.append(saveButton);

}

function populate_token_from_form(sidebarPanel, token) {
	if (token == undefined) {
		token = {};
	}
	if (sidebarPanel === undefined) {
		console.warn("populate_token_from_form was called without a sidebarPanel");
		return token;
	}

	let inputWrapper = sidebarPanel.inputWrapper;
	if (inputWrapper.length == 0) {
		// we're probably inside a builtin directory. We remove the footer to avoid users mucking with builtin data, and therefore don't have a form to populate from
		return token;
	}

	let tokenSize = inputWrapper.find(`select[name='data-token-size']`)[0].value;
	if (tokenSize == "custom") {
		tokenSize = inputWrapper.find(`input[name='data-token-size-custom']`)[0].value;
	}
	
	let tokenSizeNumber = parseInt(tokenSize);
	if (tokenSizeNumber !== undefined && typeof tokenSizeNumber === 'number') {
		token['data-token-size'] = tokenSizeNumber;
	} else {
		delete token['data-token-size'];
	}

	let tokenType = inputWrapper.find(`select[name='data-square']`)[0].value;
	switch (tokenType) {
		case "square":
			token['data-square'] = true;
			break;
		case "round": 
			token['data-square'] = false;
			break;
		default:
			delete token['data-square'];
	}

	let hideBorder = inputWrapper.find(`select[name='data-disableborder']`)[0].value;
	switch (hideBorder) {
		case "disabled": 
			token['data-disableborder'] = true;
			break;
		case "enabled":
			token['data-disableborder'] = false;
			break;
		default:
			delete token['data-disableborder'];
	}

	let aspectRatio = inputWrapper.find(`select[name='data-legacyaspectratio']`)[0].value;
	switch (aspectRatio) {
		case "legacy": 
			token['data-legacyaspectratio'] = true;
			break;
		case "maintain":
			token['data-legacyaspectratio'] = false;
			break;
		default:
			delete token['data-legacyaspectratio'];
	}

	return token;
}

function submit_custom_token_form(sidebarPanel, path) {
	if (sidebarPanel === undefined) {
		console.warn("submit_custom_token_form was called without a sidebarPanel");
		return;
	}	
	if (path === undefined) {
		console.warn("submit_custom_token_form was called without a path");
		path = "";
	}
	let folder = convert_path(path);
	if(!folder.tokens) {
		folder.tokens = {};
	}

	let inputWrapper = sidebarPanel.inputWrapper;
	
	let nameInput = inputWrapper.find(`input[name='addCustomName']`)[0];
	let name = nameInput.value;
	if (name === undefined || name.length == 0) {
		$(nameInput).css("border","1px solid red")
		$(nameInput).attr("placeholder","token name is required")
		console.warn("not saving a token with no name");
		return;
	}
	// if the token already exists, the name will be stored here. Use it to find the token object as well as handling name changes
	let previousName = $(nameInput).attr("data-previous-name");
	let imageInput = inputWrapper.find(`input[name='addCustomImage']`)[0];
	let imageUrl = imageInput.value;

	if(imageUrl.startsWith("data:")){
		alert("You cannot use urls starting with data:");
		return;
	}

	let token;
	if (previousName != undefined && previousName.length > 0 && previousName != 'undefined') {
		token = folder.tokens[previousName];
	}

	let isNewToken = token === undefined;
	let didRename = previousName != name;

	if (didRename) {
		if (folder.tokens[name] !== undefined) {
			// prevent them from overwriting an existing token
			alert(`There is already a token named "${name}"`);
			return;
		}
		// the user renamed this token. Remove the token at the old name. We'll be saving under the new name shortly.
		delete folder.tokens[previousName];
	}

	if (isNewToken) {
		token = { 'data-img': imageUrl };
	}

	if (token['data-alternative-images'] == undefined) {
		token['data-alternative-images'] = [];
	}

	if (imageUrl != undefined && imageUrl.length > 0 && token['data-alternative-images'].at(-1) != imageUrl) {
		token['data-alternative-images'].push(imageUrl);
	}

	folder.tokens[name] = populate_token_from_form(sidebarPanel, token);
	persist_customtokens();
	
	if (isNewToken || didRename) {
		// redraw the entire modal so we get all the updated information about the token. 
		// if you submit the same name twice in a row, we seem to get a cached DOM element for some reason
		// TODO: figure out everything that needs to be updated, and do that instead of redrawing the entire thing
		display_custom_token_form(path, name, token);
	} else {
		redraw_images_in_modal_body(sidebarPanel.body, path, name, token);
	}
	// just reload the body instead of the entire modal
	
	fill_tokenmenu(path);
	update_modal_images(sidebarPanel, folder.tokens[name]);
}

function update_modal_images(sidebarPanel, token) {

	if (token === undefined) {
		console.warn("update_modal_images was called without a token");
		return;
	}

	let items = sidebarPanel.body.find(".custom-token-image-item");

	// use token override if it exists, else fall back to global setting
	let tokenSquareSetting = token["data-square"];
	let globalSquareSetting = window.TOKEN_SETTINGS["square"];
	if (tokenSquareSetting == true) {
		items.find("img").removeClass("token-round");
	} else if (tokenSquareSetting == false) {
		items.find("img").addClass("token-round");
	} else if (globalSquareSetting == true) {
		items.find("img").removeClass("token-round");
	} else {
		items.find("img").addClass("token-round");
	}

	let tokenBorderSetting = token["data-disableborder"];
	let globalBorderSetting = window.TOKEN_SETTINGS["disableborder"];
	if (tokenBorderSetting == true) {
		items.find("img").css("border", "0px solid #000")
	} else if (tokenBorderSetting == false) {
		items.find("img").css("border", "4px solid #000")
	} else if (globalBorderSetting == true) {
		items.find("img").css("border", "0px solid #000")
	} else {
		items.find("img").css("border", "4px solid #000")
	}

	let tokenLegacyaspectratio = token["data-legacyaspectratio"];
	let globalLegacyaspectratio = window.TOKEN_SETTINGS["legacyaspectratio"];
	if (tokenLegacyaspectratio == true) {
		items.find("img").removeClass("preserve-aspect-ratio");
	} else if (tokenLegacyaspectratio == false) {
		items.find("img").addClass("preserve-aspect-ratio");
	} else if (globalLegacyaspectratio == true) {
		items.find("img").removeClass("preserve-aspect-ratio");
	} else {
		items.find("img").addClass("preserve-aspect-ratio");
	}

	items.attr("data-token-size", token["data-token-size"]);
}

function random_image_for_token(path, name) {
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to find a token with name ${name}, and path ${path}`);
		return "";
	}
	let images = token['data-alternative-images'];
	if (images === undefined || images.length == 0) {
		images = [ token['data-img'] ];
	}
	let randomIndex = getRandomInt(0, images.length);
	let randomImage = images[randomIndex];
	return parse_img(randomImage);
}

function place_token_from_modal(path, name, hidden, specificImage, eventPageX, eventPageY) {
	if (path === undefined) {
		path = find_best_path(name);
	}
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to place a token with name ${name}, and path ${path}`);
		return;
	}

	let options = {
		name: name,
		square: token['data-square'],
		disableborder: token['data-disableborder'],
		legacyaspectratio: token['data-legacyaspectratio'],
		hidden: hidden,
		tokendatapath: path,
		tokendataname: name,
		disablestat: true
	};

	if (specificImage === undefined) {
		options.imgsrc = random_image_for_token(path, name);
	} else {
		options.imgsrc = specificImage;
	}

	// set reasonable defaults
	if (options.square === undefined) {
		options.square = window.TOKEN_SETTINGS["square"];
		if (options.square == undefined) {
			options.square = false;
		}
	}
	if (options.disableborder === undefined) {
		options.disableborder = window.TOKEN_SETTINGS["disableborder"];
		if (options.disableborder == undefined) {
			options.disableborder = false;
		}
	}
	if (options.legacyaspectratio === undefined) {
		options.legacyaspectratio = window.TOKEN_SETTINGS["legacyaspectratio"];
		if (options.legacyaspectratio == undefined) {
			options.legacyaspectratio = false;
		}
	}

	let tokenSizeSetting = token['data-token-size'];
	let tokenSize = parseInt(tokenSizeSetting);
	if (tokenSizeSetting === undefined || typeof tokenSizeSetting !== 'number') {
		tokenSize = 1;
		// TODO: handle custom sizes
	}
	options.tokenSize = tokenSize;

	if (eventPageX === undefined || eventPageY === undefined) {
		place_token_in_center_of_map(options);
	} else {
		place_token_under_cursor(options, eventPageX, eventPageY);
	}
}

function display_placed_token_customization_modal(placedToken) {
	if (placedToken === undefined) {
		console.warn("Attempted to call display_placed_token_customization_modal without a token");
		return;
	}

	// close any that are already open. This shouldn't be necessary, but it doesn't hurt just in case
	close_sidebar_modal();

	let monsterId = placedToken.options.monster;
	if (monsterId !== undefined) {
		window.StatHandler.getStat(monsterId, function(stat) {
			display_monster_customization_modal(placedToken, monsterId, placedToken.options.name, stat.data.avatarUrl);
		});
		return;
	}

	let tokenDataPath = placedToken.options.tokendatapath;
	let tokenDataName = placedToken.options.tokendataname !== undefined ? placedToken.options.tokendataname : placedToken.options.name;

	if (tokenDataPath === undefined) {
		let matchingPaths = find_token_paths(tokenDataName);
		if (matchingPaths.length == 1) {
			tokenDataPath = matchingPaths[0];
		} else {
			console.warn(`Failed to find a matching path for token with name ${tokenDataName}`);


			// TODO: build token association feature here


		}
	}

	let savedTokenData = find_token_at_path(tokenDataPath, tokenDataName);
	if (savedTokenData !== undefined) {
		if (savedTokenData['data-alternative-images'] === undefined) {
			savedTokenData['data-alternative-images'] = [];
		}
	} else {
		console.warn(`Failed to find a token with path ${tokenDataPath}`);
	}

	// build the modal header
	let explanationText = "Click an image below to update your token or enter a new image URL at the bottom.";
	if (savedTokenData === undefined) {
		explanationText = "Enter a new image URL at the bottom.";
	}

	let sidebarPanel = new SidebarPanel("custom-token-customization-modal");
	display_sidebar_modal(sidebarPanel);
	sidebarPanel.updateHeader(placedToken.options.name, "", explanationText);

	// configure the modal body
	let modalBody = sidebarPanel.body;
	// add all of the tokens images to the body
	redraw_images_in_modal_body(modalBody, tokenDataPath, tokenDataName, savedTokenData, placedToken);

	// build the modal footer
	const add_token_customization_image = function(imageUrl) {
		if(imageUrl.startsWith("data:")){
			alert("You cannot use urls starting with data:");
			return;
		}

		if (savedTokenData === undefined) {
			// this is an unassociated token. Blindly swap the url and close the modal
			placedToken.options.imgsrc = parse_img(imageUrl);
			close_sidebar_modal();
			placedToken.place_sync_persist();
		} else {
			let tokenDataName = placedToken.options.tokendataname !== undefined ? placedToken.options.tokendataname : placedToken.options.name;
			add_image_to_token_data(imageUrl, tokenDataPath, tokenDataName); // save the image
			redraw_images_in_modal_body(modalBody, tokenDataPath, tokenDataName, savedTokenData, placedToken);
		}
	};
	
	let imageInput = sidebarPanel.build_image_url_input("Enter a new image URL", add_token_customization_image);
	imageInput.find(`.token-image-modal-add-button`).remove();
	sidebarPanel.inputWrapper.append(imageInput);

	// allow them to use the new url for the placed token without saving the url for all future monsters
	let onlyForThisTokenButton = $(`<button class="sidebar-panel-footer-button" title="This url will be used for this token only. New tokens will continue to use the images shown above.">Set for this token only</button>`);
	onlyForThisTokenButton.click(function(event) {
		let imageUrl = $(`input[name='addCustomImage']`)[0].value;
		if (imageUrl != undefined && imageUrl.length > 0) {
			placedToken.options.imgsrc = parse_img(imageUrl);
			close_sidebar_modal();
			placedToken.place_sync_persist();
		}
	});
	sidebarPanel.inputWrapper.append(onlyForThisTokenButton);

	if (savedTokenData !== undefined && !is_builtin(tokenDataPath)) {
		// Only show the add for all button if the placed token has been associated with a saved token object. We can't save what we don't know about
		let addForAllButton = $(`<button class="sidebar-panel-footer-button" title="New tokens will use this new image. If you have more than one image, one will be chosen at random when you place a new token.">Add for all future tokens</button>`);
		addForAllButton.click(function(event) {
			let imageUrl = $(`input[name='addCustomImage']`)[0].value;
			if (imageUrl != undefined && imageUrl.length > 0) {
				add_image_to_token_data(imageUrl, tokenDataPath, placedToken.options.name);
				display_placed_token_customization_modal(placedToken);	
			}
		});
		sidebarPanel.inputWrapper.append(addForAllButton);
	}

	sidebarPanel.inputWrapper.append($(`<div class="sidebar-panel-header-explanation" style="padding:4px;">You can access this modal from the Tokens tab by clicking the button on the right side of the token row.</div>`));
	update_modal_images(sidebarPanel, savedTokenData);
}

function redraw_images_in_modal_body(modalBody, path, name, tokenData, placedToken) {
	if (tokenData === undefined) {
		// Don't display any images if we haven't associated a saved token yet. 
		// We don't want to give the impression that the user could interact with this image. 
		// Once the placed token has been associated with a saved token, then this will work as expected.
		return;
	}

	// clear it out before we fill it up
	modalBody.empty();
	
	let tokenSize = tokenData['data-token-size'];
	let dataImg = parse_img(tokenData['data-img']);

	// clone our images array instead of using a reference so we don't accidentally change the currently images for all tokens
	// we also need to parse and compare every image to know if we need to add the placedToken image
	let images = [];
	for (let i = 0; i < tokenData['data-alternative-images'].length; i++) {
		let parsedImage = parse_img(tokenData['data-alternative-images'][i]);
		images.push(parsedImage);
	}
	
	let indexOffset = 0;
	if (dataImg !== undefined && !images.includes(dataImg)) {
		// the main image somehow isn't in the list so put it at the front
		images.unshift(dataImg);
		indexOffset++;
	}

	if (placedToken !== undefined) {
		if (placedToken.options.tokenSize !== undefined) {
			tokenSize = placedToken.options.tokenSize;
		}
		if (placedToken.options.name !== undefined && placedToken.options.name != name) {
			name = placedToken.options.name;
		}
		let placedImg = parse_img(placedToken.options.imgsrc);
		if (placedImg !== undefined && !images.includes(placedImg)) {
			// the placedToken image has been changed by the user so put it at the front
			images.unshift(placedImg);
			indexOffset++;
		}
	}
	if (tokenSize === undefined) {
		tokenSize = 1;
	}

	
	for (let i = 0; i < images.length; i++) { 
		let imageUrl = parse_img(images[i]);
		let tokenDiv = build_custom_token_item(name, imageUrl, tokenSize, i - indexOffset);
		if (placedToken !== undefined) {
			// if they click this image, update the placedToken and close the modal
			tokenDiv.click(function() {
				placedToken.options.imgsrc = imageUrl;
				close_sidebar_modal();
				placedToken.place_sync_persist();
			});
			if (placedToken.options.tokendatapath !== undefined) {
				tokenDiv.attr("tokendatapath", placedToken.options.tokendatapath);
			} else {
				tokenDiv.attr("data-tokendatapath", path);
			}
			if (placedToken.options.tokendataname !== undefined) {
				tokenDiv.attr("data-tokendataname", placedToken.options.tokendataname);
			} else {
				tokenDiv.attr("data-tokendataname", name);	
			}
		} else {
			tokenDiv.attr("data-tokendatapath", path);
			tokenDiv.attr("data-tokendataname", name);
		}
		modalBody.append(tokenDiv);
	}
}

function find_token_paths(name) {

	let paths = [];

	const checkFolder = function(folder, currentPath) {
		if (folder == undefined) {
			// that's as deep as we can go in this folder
			return;
		}
		if (folder.tokens != undefined && folder.tokens[name] != undefined) {
			// fond at the currentPath so let's add it to the list
			paths.push(currentPath);
		}
		for(let folderName in folder.folders) {
			// found nested folders, let's look in those as well
			let folderObject = folder.folders[folderName];
			checkFolder(folderObject, `${currentPath}/${folderName}`);
		}
	};

	checkFolder(tokendata, "");

	return paths;
}

function find_best_path(name) {
	let matchingPaths = find_token_paths(name);
	if (matchingPaths !== undefined && matchingPaths.length == 1) {
		return matchingPaths[0];
	} else {
		console.warn(`find_best_path could not determine the best path for name: ${name}`);
		return undefined;
	}
}

function find_token_at_path(path, name) {
	if (path === undefined) {
		// This could be a token that was placed before this feature went live. try to recover if we can
		path = find_best_path(name);
		if (path === undefined) {
			console.warn(`find_token_at_path was called with an invalid path: ${path}`);
			return undefined;
		}
	}
	if (name === undefined || name.length < 1) {
		console.warn(`find_token_at_path was called with an invalid name: ${name}`);
		return undefined;
	}
	let folder = convert_path(path);
	if (folder === undefined) {
		console.warn(`find_token_at_path could not find a folder at path ${path}`);
		return undefined;
	}
	if (folder.tokens === undefined) {
		console.warn(`find_token_at_path could not find any tokens at path ${path}`);
		return undefined;
	}
	let token = folder.tokens[name];
	if (token === undefined) {
		console.warn(`find_token_at_path could not find a token with the name ${name} at path ${path}`);
	}
	return token;
}

function save_token_data(tokenData, path, name) {
	let folder = convert_path(path);
	if (folder === undefined) {
		console.warn(`failed to save token data at invalid path ${path}`);
		return;
	}
	if (folder.tokens === undefined) {
		folder.tokens = {};
	}
	folder.tokens[name] = tokenData;
	persist_customtokens();
}

function add_image_to_token_data(imageUrl, path, name) {
	if (imageUrl === undefined || imageUrl.length == 0) {
		return;
	}
	if (path === undefined) {
		path = find_best_path(name);
		if (path === undefined) {
			console.warn(`failed to find token with name ${name} at path ${path}`);
			return;
		}
	}
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to find token with name ${name} at path ${path}`);
		return;
	}
	migrate_token_image_data(token);
	token['data-alternative-images'].push(parse_img(imageUrl));
	save_token_data(token, path, name);
}

function remove_image_from_token_data(path, name, index) {
	if (path == undefined) {
		path = find_best_path(name);
		if (path == undefined) {
			console.warn(`failed to find token with name ${name} at path ${path}`);
			return;
		}
	}
	let token = find_token_at_path(path, name);
	if (token == undefined) {
		console.warn(`failed to find token with name ${name} at path ${path}`);
		return;
	}
	let customImages = token['data-alternative-images'];
	if (customImages == undefined) {
		// user is removing the only image
		token['data-img'] = "";
	} else if (customImages.length > index) {
		let imageBeingRemoved = customImages[index];
		customImages.splice(index, 1);
		token['data-alternative-images'] = customImages;
		if (imageBeingRemoved == token['data-img']) {
			// the user removed the first image. Try to replace it with whatever is first now
			token['data-img'] = customImages.length > 0 ? customImages[0] : "";
		}
	}
	save_token_data(token, path, name);
}

function migrate_token_image_data(token) {
	if (token === undefined) {
		console.warn("migrate_token_image_data called without a token");
		return;
	}

	let dataImg = parse_img(token['data-img']);
	if (dataImg === undefined) {
		// nothing to migrate
		return;
	}

	if (token['data-alternative-images'] === undefined) {
		// it's not set at all so we can just set it to the data-img value
		token['data-alternative-images'] = [ dataImg ];
	} else {
		// let's parse all our urls and make sure they resolve properly before comparing them
		let images = [];
		for (let i = 0; i < token['data-alternative-images'].length; i++) {
			let parsedImage = parse_img(token['data-alternative-images'][i]);
			images.push(parsedImage);
		}
		if (!images.includes(dataImg)) {
			images.unshift(dataImg);
		}
		token['data-alternative-images'] = images;
	}
}

function delete_folder(path) {
	if (path === undefined || path == "" || is_builtin(path)) {
		console.log(`delete_folder called with ${path}`);
		return;
	}
	let parts = path.split("/");
	let folderName = parts.pop();
	let leadingPath = parts.join("/");
	let containingFolder = convert_path(leadingPath);
	delete containingFolder[folderName];
}

function containing_folder_path(path) {
	if (path === undefined || path.length == 0) {
		return "";
	}
	return path.substring(0, path.lastIndexOf("/"));
}

function context_menu_flyout(id, hoverEvent, buildFunction) {
	let contextMenu = $("#tokenOptionsPopup");
	if (contextMenu.length === 0) {
		console.warn("context_menu_flyout, but #tokenOptionsPopup could not be found");
		return;
	}

	try {
		clearTimeout(window.context_menu_flyout_timer);
	} catch (e) {
		console.debug("failed to clear window.context_menu_flyout_timer", window.context_menu_flyout_timer);
	}

	if (hoverEvent.type === "mouseenter") {
		let flyout = $(`<div id='${id}' class='context-menu-flyout'></div>`);
		$(`.context-menu-flyout`).remove(); // never duplicate

		buildFunction(flyout);
		$("#tokenOptionsContainer").append(flyout);

		let contextMenuCenter = (contextMenu.height() / 2);
		let flyoutHeight = flyout.height();
		let diff = (contextMenu.height() - flyoutHeight);
		let flyoutTop = contextMenuCenter - (flyoutHeight / 2); // center alongside the contextmenu


		if (diff > 0) {
			// the flyout is smaller than the contextmenu. Make sure it's alongside the hovered row			
			// align to the top of the row
			let buttonPosition = $(".flyout-from-menu-item:hover")[0].getBoundingClientRect().y - $("#tokenOptionsPopup")[0].getBoundingClientRect().y
			if(buttonPosition < contextMenuCenter) {
				flyoutTop =  buttonPosition - (flyoutHeight / 5)
			}
			else{
				flyoutTop =  buttonPosition - (flyoutHeight / 1.2)
			}				
		}	

		flyout.css({
			left: contextMenu.width(),
			top: flyoutTop,
		});

		if ($(".context-menu-flyout")[0].getBoundingClientRect().top < 0) {
			flyout.css("top", 0)
		}
		else if($(".context-menu-flyout")[0].getBoundingClientRect().bottom > window.innerHeight-15) {
			flyout.css({
				top: 'unset',
				bottom: 0
			});
		}
		
	} 
}

/**
 * Opens a sidebar modal with token configuration options
 * @param tokenIds {Array<String>} an array of ids for the tokens being configured
 */

function token_context_menu_expanded(tokenIds, e) {
	if (tokenIds === undefined || tokenIds.length === 0) {
		console.warn(`token_context_menu_expanded was called without any token ids`);
		return;
	}

	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined)

	if (tokens.length === 0) {
		console.warn(`token_context_menu_expanded was called with ids: ${JSON.stringify(tokenIds)}, but no matching tokens could be found`);
		return;
	}
	$("#tokenOptionsPopup").remove();
	let tokenOptionsClickCloseDiv = $("<div id='tokenOptionsClickCloseDiv'></div>");
	tokenOptionsClickCloseDiv.off().on("click", function(){
		$("#tokenOptionsPopup").remove();
		$('.context-menu-list').trigger('contextmenu:hide')
		tokenOptionsClickCloseDiv.remove();
		$(".sp-container").spectrum("destroy");
		$(".sp-container").remove();
		$(`.context-menu-flyout`).remove(); 
	});

	let moveableTokenOptions = $("<div id='tokenOptionsPopup'></div>");

	
	let body = $("<div id='tokenOptionsContainer')></div>");
	moveableTokenOptions.append(body);

	$('body').append(moveableTokenOptions);
	$('body').append(tokenOptionsClickCloseDiv);

	// stat block / character sheet
	if (tokens.length === 1) {
		let token = tokens[0];
		if (token.isPlayer() && window.DM) {
			let button = $(`<button>Open Character Sheet<span class="material-icons icon-view"></span></button>`);
			button.on("click", function() {
				open_player_sheet(token.options.id);
			});
			body.append(button);
		} else if (token.isMonster()) {
			let button = $(`<button>Open Monster Stat Block<span class="material-icons icon-view"></span></button>`);
			button.on("click", function() {
				open_monster_stat_block_with_id(token.options.monster, token.options.id);
				load_monster_stat(token.options.monster, token.options.id);
			});
			if(token.options.player_owned || window.DM){
				body.append(button);
			}
		}
	}

	if(window.DM){
		let addButtonInternals = `Add to Combat Tracker<span class="material-icons icon-person-add"></span>`;
		let removeButtonInternals = `Remove From Combat Tracker<span class="material-icons icon-person-remove"></span>`;
		let combatButton = $(`<button></button>`);
		let inCombatStatuses = [...new Set(tokens.map(t => t.options.combat))];
		if (inCombatStatuses.length === 1 && inCombatStatuses[0] === true) {
			// they are all in the combat tracker. Make it a remove button
			combatButton.addClass("remove-from-ct");
			combatButton.html(removeButtonInternals);
		} else {
			// if any are not in the combat tracker, make it an add button.
			combatButton.addClass("add-to-ct");
			combatButton.html(addButtonInternals);
		}
		combatButton.on("click", function(clickEvent) {
			let clickedButton = $(clickEvent.currentTarget);
			if (clickedButton.hasClass("remove-from-ct")) {
				clickedButton.removeClass("remove-from-ct").addClass("add-to-ct");
				clickedButton.html(addButtonInternals);
				tokens.forEach(t => ct_remove_token(t, false));
			} else {
				clickedButton.removeClass("add-to-ct").addClass("remove-from-ct");
				clickedButton.html(removeButtonInternals);
				tokens.forEach(t => ct_add_token(t, false));
			}
			ct_persist();
		});
		body.append(combatButton);

	
		let hiddenMenuButton = $(`<button class="`+determine_hidden_classname(tokenIds) + `context-menu-icon-condition icon-invisible material-icons">Hide/Reveal Token</button>`)

		hiddenMenuButton.off().on("click", function(tokenIds){
			let clickedItem = $(this);
			let hideAll = clickedItem.hasClass("some-active");
			tokens.forEach(token => {
				if (hideAll || token.options.hidden !== true) {
					token.hide();
				} else {
					token.show();
				}
				token.place_sync_persist();
			});
			clickedItem.removeClass("single-active all-active some-active active-condition");
			clickedItem.addClass(determine_hidden_classname(tokenIds));
		});

		body.append(hiddenMenuButton);
	}
	

	if (tokens.length === 1) {
		body.append(build_menu_stat_inputs(tokenIds));
	}

	
	if(tokens[0].isPlayer()){ 
		$(".maxHpMenuInput").prop('disabled', true);
		$(".acMenuInput").prop('disabled', true);
		$(".hpMenuInput").prop('disabled', true);
	}
	if(!window.DM){ 
		$(".maxHpMenuInput").prop('disabled', true);
		$(".acMenuInput").prop('disabled', true);
		$(".hpMenuInput").prop('disabled', true);
	}	
	if(tokens[0].options.player_owned && !tokens[0].isPlayer()){ 
		$(".maxHpMenuInput").prop('disabled', false);
		$(".acMenuInput").prop('disabled', false);
		$(".hpMenuInput").prop('disabled', false);
	}


	let conditionsRow = $(`<div class="token-image-modal-footer-select-wrapper flyout-from-menu-item"><div class="token-image-modal-footer-title">Conditions / Markers</div></div>`);
	conditionsRow.hover(function (hoverEvent) {
		context_menu_flyout("conditions-flyout", hoverEvent, function(flyout) {
			flyout.append(build_conditions_and_markers_flyout_menu(tokenIds));
		})
	});
	body.append(conditionsRow);
	let adjustmentsRow = $(`<div class="token-image-modal-footer-select-wrapper flyout-from-menu-item"><div class="token-image-modal-footer-title">Token Adjustments</div></div>`);
	adjustmentsRow.hover(function (hoverEvent) {
		context_menu_flyout("adjustments-flyout", hoverEvent, function(flyout) {
			flyout.append(build_adjustments_flyout_menu(tokenIds));
		})
	});
	if(window.DM || (tokens.length == 1 && (tokens[0].options.player_owned == true || tokens[0].isPlayer()))){
		body.append(adjustmentsRow);
	}

	// Auras (torch, lantern, etc)
	let aurasRow = $(`<div class="token-image-modal-footer-select-wrapper flyout-from-menu-item"><div class="token-image-modal-footer-title">Token Auras</div></div>`);
	aurasRow.hover(function (hoverEvent) {
		context_menu_flyout("auras-flyout", hoverEvent, function(flyout) {
			flyout.append(build_token_auras_inputs(tokenIds));
		})
	});
	if(window.DM || (tokens.length == 1 && (tokens[0].options.player_owned == true || tokens[0].isPlayer()))){
		body.append(aurasRow);
	}
	if(window.DM) {
		if (tokens.length === 1) {
			let notesRow = $(`<div class="token-image-modal-footer-select-wrapper flyout-from-menu-item"><div class="token-image-modal-footer-title">Token Note</div></div>`);
			notesRow.hover(function (hoverEvent) {
				context_menu_flyout("notes-flyout", hoverEvent, function(flyout) {
					flyout.append(build_notes_flyout_menu(tokenIds));
				})
			});
			body.append(notesRow);
		}
	}

	if(window.DM) {
		let optionsRow = $(`<div class="token-image-modal-footer-select-wrapper flyout-from-menu-item"><div class="token-image-modal-footer-title">Options</div></div>`);
		optionsRow.hover(function (hoverEvent) {
			context_menu_flyout("options-flyout", hoverEvent, function(flyout) {
				flyout.append(build_options_flyout_menu(tokenIds));
			})
		});
		body.append(optionsRow);
	}
	moveableTokenOptions.css("left", e.pageX - 245 + 'px');

	if($(moveableTokenOptions).height() > window.innerHeight - e.pageY - 20) {
		moveableTokenOptions.css({
	        "top": window.innerHeight - $(moveableTokenOptions).height() - 20 + 'px',
	    });
	}
	else {
		moveableTokenOptions.css({
        	"top": e.pageY + 'px',
        });
	}

	if(window.DM) {
		let deleteTokenMenuButton = $("<button class='deleteMenuButton icon-close-red material-icons'>Delete</button>")
	 	body.append(deleteTokenMenuButton);
	 	deleteTokenMenuButton.off().on("click", function(){
	 		if(!$(e.target).hasClass("tokenselected")){
	 			deselect_all_tokens();
	 		}
	 		tokens.forEach(token => {
	 			token.selected = true;
	 		});
			delete_selected_tokens()
	 	});
	 }


	$("#tokenOptionsPopup").addClass("moveableWindow");
	$("#tokenOptionsPopup").draggable({
			addClasses: false,
			scroll: false,
			containment: "#windowContainment",
			start: function () {
				$("#resizeDragMon").append($('<div class="iframeResizeCover"></div>'));			
				$("#sheet").append($('<div class="iframeResizeCover"></div>'));
			},
			stop: function () {
				$('.iframeResizeCover').remove();

			}
		});
	$("#tokenOptionsPopup").resizable({
		addClasses: false,
		handles: "all",
		containment: "#windowContainment",
		start: function () {
			$("#resizeDragMon").append($('<div class="iframeResizeCover"></div>'));			
			$("#sheet").append($('<div class="iframeResizeCover"></div>'));
		},
		stop: function () {
			$('.iframeResizeCover').remove();
		},
		minWidth: 215,
		minHeight: 200
	});
	
	$("#tokenOptionsPopup").mousedown(function() {
		frame_z_index_when_click($(this));
	});
	
}

/**
 * Builds and returns HTML inputs for updating token auras
 * @param tokens {Array<Token>} the token objects that the aura configuration HTML is for
 * @returns {*|jQuery|HTMLElement}
 */
function build_token_auras_inputs(tokenIds) {
	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div></div>");
	body.css({
		width: "290px", // once we add Markers, make this wide enough to contain them all
		padding: "5px",
		display: "flex",
		"flex-direction": "row"
	})

	let auraVisibleValues = tokens.map(t => t.options.auraVisible);
	let uniqueAuraVisibleValues = [...new Set(auraVisibleValues)];

	let auraIsEnabled = null;
	if (uniqueAuraVisibleValues.length === 1) {
		auraIsEnabled = uniqueAuraVisibleValues[0];
	}
	let aura1Feet = tokens.map(t => t.options.aura1.feet);
	let uniqueAura1Feet = aura1Feet.length === 1 ? aura1Feet[0] : ""
	let aura2Feet = tokens.map(t => t.options.aura2.feet);
	let uniqueAura2Feet = aura2Feet.length === 1 ? aura2Feet[0] : ""
	let aura1Color = tokens.map(t => t.options.aura1.color);
	let uniqueAura1Color = aura1Color.length === 1 ? aura1Color[0] : ""
	let aura2Color = tokens.map(t => t.options.aura2.color);
	let uniqueAura2Color = aura2Color.length === 1 ? aura2Color[0] : ""

	let upsq = 'ft';
	if (window.CURRENT_SCENE_DATA.upsq !== undefined && window.CURRENT_SCENE_DATA.upsq.length > 0) {
		upsq = window.CURRENT_SCENE_DATA.upsq;
	}
	let wrapper = $(`
		<div class="token-config-aura-input">

			<div class="token-config-aura-wrapper">
				<div class="token-image-modal-footer-select-wrapper">
					<div class="token-image-modal-footer-title">Preset</div>
					<select class="token-config-aura-preset">
						<option value="none"></option>
						<option value="candle">Candle (5/5)</option>
						<option value="torch">Torch / Light (20/20)</option>
						<option value="lamp">Lamp (15/30)</option>
						<option value="lantern">Lantern (30/30)</option>
					</select>
				</div>
				<div class="menu-inner-aura">
					<h3 style="margin-bottom:0px;">Inner Aura</h3>
					<div class="token-image-modal-footer-select-wrapper" style="padding-left: 2px">
						<div class="token-image-modal-footer-title">Radius (${upsq})</div>
						<input class="aura-radius" name="aura1" type="text" value="${uniqueAura1Feet}" style="width: 3rem" />
					</div>
					<div class="token-image-modal-footer-select-wrapper" style="padding-left: 2px">
						<div class="token-image-modal-footer-title">Color</div>
						<input class="spectrum" name="aura1Color" value="${uniqueAura1Color}" >
					</div>
				</div>
				<div class="menu-outer-aura">
					<h3 style="margin-bottom:0px;">Outer Aura</h3>
					<div class="token-image-modal-footer-select-wrapper" style="padding-left: 2px">
						<div class="token-image-modal-footer-title">Radius (${upsq})</div>
						<input class="aura-radius" name="aura2" type="text" value="${uniqueAura2Feet}" style="width: 3rem" />
					</div>
					<div class="token-image-modal-footer-select-wrapper" style="padding-left: 2px">
						<div class="token-image-modal-footer-title">Color</div>
						<input class="spectrum" name="aura2Color" value="${uniqueAura1Color}" >
					</div>
				</div>
			</div>
		</div>
	`);

	let enabledAurasInput = build_toggle_input("auraVisible", "Enable Token Auras", auraIsEnabled, undefined, undefined, function(name, newValue) {
		console.log(`${name} setting is now ${newValue}`);
		tokens.forEach(token => {
			token.options[name] = newValue;
			token.place_sync_persist();
		});
		if (newValue) {
			wrapper.find(".token-config-aura-wrapper").show();
		} else {
			wrapper.find(".token-config-aura-wrapper").hide();
		}
	});
	wrapper.prepend(enabledAurasInput);
	wrapper.find("h3.token-image-modal-footer-title").after(enabledAurasInput);
	if (auraIsEnabled) {
		wrapper.find(".token-config-aura-wrapper").show();
	} else {
		wrapper.find(".token-config-aura-wrapper").hide();
	}

	let radiusInputs = wrapper.find('input.aura-radius');
	radiusInputs.on('keyup', function(event) {
		let newRadius = event.target.value;
		if (event.key == "Enter" && newRadius !== undefined && newRadius.length > 0) {
			tokens.forEach(token => {
				token.options[event.target.name]['feet'] = newRadius;
				token.place_sync_persist();
			});
			$(event.target).closest(".token-config-aura-wrapper").find(".token-config-aura-preset")[0].selectedIndex = 0;
		}
	});
	radiusInputs.on('focusout', function(event) {
		let newRadius = event.target.value;
		if (newRadius !== undefined && newRadius.length > 0) {
			tokens.forEach(token => {
				token.options[event.target.name]['feet'] = newRadius;
				token.place_sync_persist();
			});
			$(event.target).closest(".token-config-aura-wrapper").find(".token-config-aura-preset")[0].selectedIndex = 0;
		}
	});

	let colorPickers = wrapper.find('input.spectrum');
	colorPickers.spectrum({
		type: "color",
		showInput: true,
		showInitial: true,
		containerClassName: 'prevent-sidebar-modal-close',
		clickoutFiresChange: true
	});
	const colorPickerChange = function(e, tinycolor) {
		let auraName = e.target.name.replace("Color", "");
		let color = `rgba(${tinycolor._r}, ${tinycolor._g}, ${tinycolor._b}, ${tinycolor._a})`;
		console.log(auraName, e, tinycolor);
		if (e.type === 'change') {
			tokens.forEach(token => {
				token.options[auraName]['color'] = color;
				token.place_sync_persist();
			});
			$(e.target).closest(".token-config-aura-wrapper").find(".token-config-aura-preset")[0].selectedIndex = 0;
		} else {
			tokens.forEach(token => {
				let selector = "div[data-id='" + token.options.id + "']";
				let html = $("#tokens").find(selector);
				let options = Object.assign({}, token.options);
				options[auraName]['color'] = color;
				setTokenAuras(html, token.options)
			});
		}
	};
	colorPickers.on('move.spectrum', colorPickerChange);   // update the token as the player messes around with colors
	colorPickers.on('change.spectrum', colorPickerChange); // commit the changes when the user clicks the submit button
	colorPickers.on('hide.spectrum', colorPickerChange);   // the hide event includes the original color so let's change it back when we get it


	wrapper.find(".token-config-aura-preset").on("change", function(e) {
		let feet1 = "";
		let feet2 = "";
		let preset = e.target.value;
		if (preset === "candle") {
			feet1 = "5";
			feet2 = "5";
		} else if (preset === "torch") {
			feet1 = "20";
			feet2 = "20";
		} else if (preset === "lamp") {
			feet1 = "15";
			feet2 = "30";
		} else if (preset === "lantern") {
			feet1 = "30";
			feet2 = "30";
		} else {
			console.warn("somehow got an unexpected preset", preset, e);
		}
		let wrapper = $(e.target).closest(".token-config-aura-wrapper");
		wrapper.find("input[name='aura1']").val(feet1);
		wrapper.find("input[name='aura2']").val(feet2);

		let color1 = "rgba(255, 129, 0, 0.3)";
		let color2 = "rgba(255, 255, 0, 0.1)";
		wrapper.find("input[name='aura1Color']").spectrum("set", color1);
		wrapper.find("input[name='aura2Color']").spectrum("set", color2);

		tokens.forEach(token => {
			token.options.aura1.feet = feet1;
			token.options.aura2.feet = feet2;
			token.options.aura1.color = color1;
			token.options.aura2.color = color2;
			token.place_sync_persist();
		});
	});

	$("#VTTWRAPPER .sidebar-modal").on("remove", function () {
		console.log("removing sidebar modal!!!");
		colorPickers.spectrum("destroy");
	});
	body.append(wrapper);

	return body;
}

function build_menu_stat_inputs(tokenIds) {
	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div id='menuStatDiv'></div>");
	let hp = '';
	let max_hp = '';
	let ac = '';
	let elev = '';

	if(tokens.length == 1 && (tokens[0].options.player_owned || (!tokens[0].options.hidestat && tokens[0].isPlayer()) || window.DM)){
		hp = (typeof tokens[0].options.hp !== 'undefined') ? tokens[0].options.hp : '';
		max_hp = (typeof tokens[0].options.max_hp !==  'undefined') ? tokens[0].options.max_hp : '';
		ac = (typeof tokens[0].options.ac !== 'undefined') ? tokens[0].options.ac : '';
		elev = (typeof tokens[0].options.elev !== 'undefined') ? tokens[0].options.elev : '';
	}
	else{
		hp = "????";
		max_hp = "????";
		ac = "????";
		elev = (typeof tokens[0].options.elev !== 'undefined') ? tokens[0].options.elev : '';
	}

	let hpMenuInput = $(`<label class='menu-input-label'>HP<input value='${hp}' class='menu-input hpMenuInput' type="text"></label>`);
	let maxHpMenuInput = $(`<label class='menu-input-label'>Max HP<input value='${max_hp}' class='menu-input maxHpMenuInput' type="text"></label>`);
	let acMenuInput = $(`<label class='menu-input-label'>AC<input value='${ac}' class='menu-input acMenuInput' type="text"></label>`);
	let elevMenuInput = $(`<label class='menu-input-label'>Elevation<input value='${elev}' class='menu-input elevMenuInput' type="text"></label>`);
	body.append(elevMenuInput);
	body.append(acMenuInput);
	body.append(hpMenuInput);
	body.append(maxHpMenuInput);




	hpMenuInput.on('keyup', function(event) {
		let newValue = event.target.value;
		let newHP = newValue;

		if (event.key == "Enter" && newValue !== undefined && newValue.length > 0) {
			tokens.forEach(token => {
				if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
					newHP = parseInt(token.options.hp) + parseInt(newValue);
				}
				token.options.hp = newHP;
				token.place_sync_persist();
				$(".hpMenuInput").val(newHP);
			});
		}
	});
	hpMenuInput.on('focusout', function(event) {
		let newValue = event.target.value;
		let newHP = newValue;

		tokens.forEach(token => {
			if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
				newHP = parseInt(token.options.hp) + parseInt(newValue);
			}
			token.options.hp = newHP;
			token.place_sync_persist();
			$(".hpMenuInput").val(newHP);
		});
	});

	maxHpMenuInput.on('keyup', function(event) {
		let newValue = event.target.value;
		let newMaxHP = newValue;

		if (event.key == "Enter" && newValue !== undefined && newValue.length > 0) {
			tokens.forEach(token => {
				if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
					newMaxHP = parseInt(token.options.max_hp) + parseInt(newValue);
				}
				token.options.max_hp = newMaxHP;
				token.place_sync_persist();
				$(".maxHpMenuInput").val(newMaxHP);
			});
		}
	});
	maxHpMenuInput.on('focusout', function(event) {
		let newValue = event.target.value;
		let newMaxHP = newValue;

		tokens.forEach(token => {
			if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
				newMaxHP = parseInt(token.options.max_hp) + parseInt(newValue);
			}
			token.options.max_hp = newMaxHP;
			token.place_sync_persist();
			$(".maxHpMenuInput").val(newMaxHP);
		});
	});

	acMenuInput.on('keyup', function(event) {
		let newValue = event.target.value;
		let newAC = newValue;

		if (event.key == "Enter" && newValue !== undefined && newValue.length > 0) {
			tokens.forEach(token => {
				if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
					newAC = parseInt(token.options.ac) + parseInt(newValue);
				}
				token.options.ac = newAC;
				token.place_sync_persist();
				$(".acMenuInput").val(newAC);
			});
		}
	});
	acMenuInput.on('focusout', function(event) {
		let newValue = event.target.value;
		let newAC = newValue;

		tokens.forEach(token => {
			if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
				newAC = parseInt(token.options.ac) + parseInt(newValue);
			}
			token.options.ac = newAC;
			token.place_sync_persist();
			$(".acMenuInput").val(newAC);
		});
	});

	elevMenuInput.on('keyup', function(event) {
		let newValue = event.target.value;
		let newElev = newValue;

		if (event.key == "Enter" && newValue !== undefined && newValue.length > 0) {
			tokens.forEach(token => {
				if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
					newElev = parseInt(token.options.elev) + parseInt(newValue);
				}
				token.options.elev = newElev;
				token.place_sync_persist();
				$(".elevMenuInput").val(newElev);
			});
		}
	});
	elevMenuInput.on('focusout', function(event) {
		let newValue = event.target.value;
		let newElev = newValue;

		tokens.forEach(token => {
			if(newValue.indexOf("+") == 0 || newValue.indexOf("-") == 0){
				newElev = parseInt(token.options.elev) + parseInt(newValue);
			}
			token.options.elev = newElev;
			token.place_sync_persist();
			$(".elevMenuInput").val(newElev);
		});
	});

	return body;


}

function build_notes_flyout_menu(tokenIds) {
	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div></div>");
	let id = tokens[0].options.id;
	body.css({
		width: "200px", // once we add Markers, make this wide enough to contain them all
		padding: "5px",
		"flex-direction": "row"
	});
	let editNoteButton = $(`<button class="icon-note material-icons">Create Note</button>`)
	if(tokenIds.length=1){
		let has_note=id in window.JOURNAL.notes;
		if(has_note){
			let viewNoteButton = $(`<button class="icon-view-note material-icons">View Note</button>`)		
			let deleteNoteButton = $(`<button class="icon-note-delete material-icons">Delete Note</button>`)
			editNoteButton = $(`<button class="icon-note material-icons">Edit Note</button>`)
			body.append(viewNoteButton);
			body.append(editNoteButton);		
			body.append(deleteNoteButton);	
			viewNoteButton.off().on("click", function(){
				window.JOURNAL.display_note(id);
			});
			deleteNoteButton.off().on("click", function(){
				if(id in window.JOURNAL.notes){
					delete window.JOURNAL.notes[id];
					window.JOURNAL.persist();
					window.TOKEN_OBJECTS[id].place();
				}
			});
		}
		else {
			body.append(editNoteButton);
		}

		editNoteButton.off().on("click", function(){
			if (!(id in window.JOURNAL.notes)) {
				window.JOURNAL.notes[id] = {
					title: window.TOKEN_OBJECTS[id].options.name,
					text: '',
					plain: '',
					player: false
				}
			}
			window.JOURNAL.edit_note(id);
		});		
	}

	return body;
}

	

function build_conditions_and_markers_flyout_menu(tokenIds) {

	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div></div>");
	body.css({
		width: "380px", // once we add Markers, make this wide enough to contain them all
		padding: "5px",
		display: "flex",
		"flex-direction": "row"
	})

	const buildConditionItem = function(conditionName) {

		let conditionItem = $(`<li class="${determine_condition_item_classname(tokenIds, conditionName)} icon-${conditionName.toLowerCase().replaceAll("(", "-").replaceAll(")", "").replaceAll(" ", "-")}"></li>`);
		if (conditionName.startsWith("#")) {
			let colorItem = $(`<span class="color-condition"></span>`);
			conditionItem.append(colorItem);
			colorItem.css("background-color", conditionName);
		} else {
			conditionItem.append(`<span>${conditionName}</span>`);
		}

		conditionItem.on("click", function (clickEvent) {
			let clickedItem = $(clickEvent.currentTarget);
			let deactivateAll = clickedItem.hasClass("some-active");
			tokens.forEach(token => {
				if (deactivateAll || token.hasCondition(conditionName)) {
					token.removeCondition(conditionName)
				} else {
					token.addCondition(conditionName)
				}
				token.place_sync_persist();
			});
			clickedItem.removeClass("single-active all-active some-active active-condition");
			clickedItem.addClass(determine_condition_item_classname(tokenIds, conditionName));
		});
		return conditionItem;
	};

	let conditionsList = $(`<ul></ul>`);
	conditionsList.css("width", "180px");
	body.append(conditionsList);
	STANDARD_CONDITIONS.forEach(conditionName => {
		let conditionItem = buildConditionItem(conditionName);
		conditionItem.addClass("icon-condition");
		conditionsList.append(conditionItem);
	});

	let markersList = $(`<ul></ul>`);
	markersList.css("width", "185px");
	body.append(markersList);
	CUSTOM_CONDITIONS.forEach(conditionName => {
		let conditionItem = buildConditionItem(conditionName);
		conditionItem.addClass("markers-icon");
		markersList.append(conditionItem);

	});

	let removeAllItem = $(`<li class="icon-condition icon-close-red"><span>Remove All</span></li>`);
	removeAllItem.on("click", function () {
		$(".active-condition").click(); // anything that is active should be deactivated.

	});
	conditionsList.prepend(removeAllItem);

	return body;
}

function build_adjustments_flyout_menu(tokenIds) {
	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div></div>");
	body.css({
		width: "320px",
		padding: "5px"
	});
	// name
	let tokenNames = tokens.map(t => t.options.name);
	let uniqueNames = [...new Set(tokenNames)];
	let nameInput = $(`<input title="Token Name" placeholder="Token Name" name="name" type="text" />`);
	if (uniqueNames.length === 1) {
		nameInput.val(tokenNames[0]);
	} else {
		nameInput.attr("placeholder", "Multiple Values");
	}

	nameInput.on('keyup', function(event) {
		let newName = event.target.value;
		if (event.key == "Enter" && newName !== undefined && newName.length > 0) {
			tokens.forEach(token => {
				token.options.name = newName;
				token.place_sync_persist();
			});
		}
	});
	nameInput.on('focusout', function(event) {
		let newName = event.target.value;
		if (newName !== undefined && newName.length > 0) {
			tokens.forEach(token => {
				token.options.name = newName;
				token.place_sync_persist();
			});
		}
	});
	let nameWrapper = $(`
		<div class="token-image-modal-url-label-wrapper">
			<div class="token-image-modal-footer-title">Token Name</div>
		</div>
	`);
	nameWrapper.append(nameInput); // input below label
	body.append(nameWrapper);


	// size
	let tokenSizes = tokens.map(t => t.gridSize());
	let uniqueSizes = [...new Set(tokenSizes)];
	console.log("uniqueSizes", uniqueSizes);
	let sizeInputs = build_token_size_input(1, function (newSize) {
		tokens.forEach(token => {
			if (newSize === 0) {
				// tiny comes back as 0 but it's actually 0.5
				token.size(Math.round(window.CURRENT_SCENE_DATA.hpps) * 0.5);
			} else if (!isNaN(newSize)) {
				token.size(Math.round(window.CURRENT_SCENE_DATA.hpps) * newSize);
			} else {
				console.log(`not updating tokens with size ${newSize}`); // probably undefined because we inject the "multiple" options below
			}
		});
	});
	if (uniqueSizes.length === 1) {
		sizeInputs.find(`select > option[value="${uniqueSizes[0]}"]`).attr("selected", "selected");
	} else {
		sizeInputs.find("select").prepend(`<option value="multiple" selected>Multiple Values</option>`);
	}
	body.append(sizeInputs);

	//image scaling size
	let imageSizeInput = $(`<input class="image-scale-input-number" type="number" max="6" min="0.2" step="0.1" title="Token Image Scale" placeholder="1.0" name="Image Scale">`);
	let imageSizeInputRange = $(`<input class="image-scale-input-range" type="range" value="1" min="0.2" max="6" step="0.1"/>`);
	let tokenImageScales = tokens.map(t => t.options.imageSize);
	if(tokenImageScales.length === 1) {
		imageSizeInput.val(tokenImageScales[0] || 1);	
		imageSizeInputRange.val(tokenImageScales[0] || 1);
	}
	imageSizeInput.on('keyup', function(event) {
		var imageSize;
		if(event.target.value <= 6 && event.target.value >= 0.2) { 
			imageSize = event.target.value;
		}
		else if(event.target.value > 6){
			imageSize = 6;
		}
		else if(event.target.value < 0.2){
			imageSize = 0.2;
		}
		if (event.key == "Enter") {
			imageSizeInput.val(imageSize);	
			imageSizeInputRange.val(imageSize);
			tokens.forEach(token => {
				token.options.imageSize = imageSize;
				token.place_sync_persist();
			});
		}
		imageSizeInputRange.val(imageSizeInput.val());
	});
	imageSizeInput.on('focusout', function(event) {
		var imageSize;
		if(event.target.value <= 6 && event.target.value >= 0.2) { 
			imageSize = event.target.value;
		}
		else if(event.target.value > 6){
			imageSize = 6;
			imageSizeInput.val(imageSize);	
			imageSizeInputRange.val(imageSize);
		}
		else if(event.target.value < 0.2){
			imageSize = 0.2;
			imageSizeInput.val(imageSize);	
			imageSizeInputRange.val(imageSize);
		}	
		tokens.forEach(token => {
			token.options.imageSize = imageSize;
			token.place_sync_persist();
		});

		imageSizeInputRange.val(imageSizeInput.val());
	});
	imageSizeInput.on(' input change', function(){
   	 	imageSizeInputRange.val(imageSizeInput.val());
	});
	imageSizeInputRange.on(' input change', function(){
   	 	imageSizeInput.val(imageSizeInputRange.val());
	});
	imageSizeInputRange.on('mouseup', function(){
   	 	let imageSize = imageSizeInputRange.val();
		tokens.forEach(token => {
			token.options.imageSize = imageSize;
			token.place_sync_persist();
		});
	});
	let imageSizeWrapper = $(`
		<div class="token-image-modal-url-label-wrapper image-size-wrapper">
			<div class="token-image-modal-footer-title image-size-title">Token Image Scale</div>
		</div>
	`);
	imageSizeWrapper.append(imageSizeInput); // Beside Label
	imageSizeWrapper.append(imageSizeInputRange); // input below label
	body.append(imageSizeWrapper);

	//border color selections
	let borderColorInput = $(`<input class="border-color-input" type="color" value="#ddd"/>`);
	let tokenBorderColors = tokens.map(t => t.options.color);
	if(tokenBorderColors.length === 1) {
		borderColorInput.val(tokenBorderColors[0] || "#dddddd");	
	}
	let borderColorWrapper = $(`
		<div class="token-image-modal-url-label-wrapper border-color-wrapper">
			<div class="token-image-modal-footer-title border-color-title">Border Color</div>
		</div>
	`);
	borderColorWrapper.append(borderColorInput); 
	body.append(borderColorWrapper);
	let colorPicker = $(borderColorInput);
	colorPicker.spectrum({
		type: "color",
		showInput: true,
		showInitial: true,
		containerClassName: 'prevent-sidebar-modal-close',
		clickoutFiresChange: true,
		color: tokens[0].options.color
	});
	const borderColorPickerChange = function(event, tinycolor) {
		let borderColor = `rgba(${tinycolor._r}, ${tinycolor._g}, ${tinycolor._b}, ${tinycolor._a})`;
		if (event.type === 'change') {
			tokens.forEach(token => {
				token.options.color = borderColor;
				$("#combat_area tr[data-target='" + token.options.id + "'] img[class*='Avatar']").css("border-color", borderColor);
				token.place_sync_persist();
			});
		}
		else {
			tokens.forEach(token => {
				let selector = "div[data-id='" + token.options.id + "']";
				let html = $("#tokens").find(selector);
				let options = Object.assign({}, token.options);
				token.options.color = borderColor;
				
				token.place_sync_persist();	
			});
		}
	};
	colorPicker.on('dragstop.spectrum', borderColorPickerChange);   // update the token as the player messes around with colors
	colorPicker.on('change.spectrum', borderColorPickerChange); // commit the changes when the user clicks the submit button
	colorPicker.on('hide.spectrum', borderColorPickerChange);   // the hide event includes the original color so let's change it back when we get it
	

	let changeImageMenuButton = $("<button id='changeTokenImage' class='material-icons'>Change Token Image</button>")
	if(tokens.length == 1 && window.DM){
		body.append(changeImageMenuButton)
	}

	changeImageMenuButton.off().on("click", function(){	
		id = tokens[0].options.id;
		if (!(id in window.TOKEN_OBJECTS)) {
			return;
		}
		let tok = window.TOKEN_OBJECTS[id];
		let monsterId = tokens[0].options.monster;
		let name = tokens[0].options.name;
		if (tok.isPlayer()) {
			display_player_token_customization_modal(id, tok);
		} else if (monsterId !== undefined) {
			window.StatHandler.getStat(monsterId, function(stat) {
				display_monster_customization_modal(tok, monsterId, name, stat.data.avatarUrl);
			});
		} else {
			display_placed_token_customization_modal(tok);
		}
	});

	return body;
}

function build_options_flyout_menu(tokenIds) {
	let tokens = tokenIds.map(id => window.TOKEN_OBJECTS[id]).filter(t => t !== undefined);
	let body = $("<div></div>");
	body.css({
		width: "320px",
		padding: "5px"
	})
	const token_settings = [
		{ name: "hidden", label: "Hide", enabledDescription:"Token is hidden to players", disabledDescription: "Token is visible to players" },
		{ name: "square", label: "Square Token", enabledDescription:"Token is square", disabledDescription: "Token is round" },
		{ name: "locked", label: "Lock Token in Position", enabledDescription:"Token is not moveable, Players can not select this token", disabledDescription: "Token is moveable by at least the DM, players can select it however" },
		{ name: "restrictPlayerMove", label: "Restrict Player Movement", enabledDescription:"Token is not moveable by players", disabledDescription: "Token is moveable by any player" },
		{ name: "disablestat", label: "Disable HP/AC", enabledDescription:"Token stats are not visible", disabledDescription: "Token stats are visible to at least the DM" },
		{ name: "hidestat", label: "Hide Player HP/AC from players", enabledDescription:"Token stats are hidden from players", disabledDescription: "Token stats are visible to players" },
		{ name: "disableborder", label: "Disable Border", enabledDescription:"Token has no border", disabledDescription: "Token has a random coloured border"  },
		{ name: "disableaura", label: "Disable Health Meter", enabledDescription:"Token has no health glow", disabledDescription: "Token has health glow corresponding with their current health" },
		{ name: "revealname", label: "Show name to players", enabledDescription:"Token on hover name is visible to players", disabledDescription: "Token name is hidden to players" },
		{ name: "legacyaspectratio", label: "Ignore Image Aspect Ratio", enabledDescription:"Token will stretch non-square images to fill the token space", disabledDescription: "Token will respect the aspect ratio of the image provided" },
		{ name: "player_owned", label: "Player access to sheet/stats", enabledDescription:"Tokens' sheet is accessible to players via RMB click on token. If token stats is visible to players, players can modify the hp of the token", disabledDescription: "Tokens' sheet is not accessible to players. Players can't modify token stats"}
	];
	for(let i = 0; i < token_settings.length; i++) {
		let setting = token_settings[i];
		let tokenSettings = tokens.map(t => t.options[setting.name]);
		let uniqueSettings = [...new Set(tokenSettings)];
		let currentValue = null; // passing null will set the switch as unknown; undefined is the same as false
		if (uniqueSettings.length === 1) {
			currentValue = uniqueSettings[0];
		}
		let inputWrapper = build_toggle_input(setting.name, setting.label, currentValue, setting.enabledDescription, setting.disabledDescription, function(name, newValue) {
			console.log(`${name} setting is now ${newValue}`);
			tokens.forEach(token => {
				token.options[name] = newValue;
				token.place_sync_persist();
			});
		});
		body.append(inputWrapper);
	}

	let resetToDefaults = $(`<button class='token-image-modal-remove-all-button' title="Reset all token settings back to their default values." style="width:100%;padding:8px;margin:10px 0px;">Reset Token Settings to Defaults</button>`);
	resetToDefaults.on("click", function (clickEvent) {
		for (let i = 0; i < token_settings.length; i++) {
			let setting = token_settings[i];
			let toggle = $(clickEvent.target).parent().find(`button[name=${setting.name}]`);
			toggle.removeClass("rc-switch-checked");
			toggle.removeClass("rc-switch-unknown");
			tokens.forEach(token => token.options[setting.name] = false);
		}
		tokens.forEach(token => token.place_sync_persist());
	});
	body.append(resetToDefaults);
	return body;
}
