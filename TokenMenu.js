
tokenbuiltin = {
	folders: {
		'Overlays': {
			tokens: {
				'Blood': {
					'data-img': 'https://drive.google.com/file/d/1frTuvq-64DA23ayC6P0XGZyo0M6paEID/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Big Bang': {
					'data-img': 'https://drive.google.com/file/d/19pbEuWVSQo15vmlsnJry-q3ordcAlaej/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Fire': {
					'data-img': 'https://drive.google.com/file/d/1_wE3B5rvr38cM9NMbCQ__WUf0RIXIuhQ/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Flame 1': {
					'data-img': 'https://thumbs.gfycat.com/GiddyMajorDingo-small.gif',
					'data-disableborder': true,
					'data-square': true,
				},
				'Flame 2': {
					'data-img': 'https://cutewallpaper.org/21/fire-gif-transparent-background/Fire-PNG-Gif-Transparent-Fire-GifPNG-Images-PlusPNG.gif',
					'data-disableborder': true,
					'data-square': true,
				},
				'Nebula': {
					'data-img': 'https://drive.google.com/file/d/1AeoKU444D3DrtjebegH0yRXNolrqw89K/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
				'Web': {
					'data-img': 'https://drive.google.com/file/d/1rGuD7FMtzy6XR0qcsewndhS33wZL8vEM/view?usp=sharing',
					'data-disableborder': true,
					'data-square': true,
				},
			}
		},
		'Weapons': {
			tokens: {
				'Heartseeker Blade': {
					'data-img': 'https://drive.google.com/file/d/1Ft84c1VwnEhwKPew8Yyq8w8NFViC7Mr7/view?usp=sharing',
					'data-disablestat': true,
				}
			}
		},
	},
	tokens: {
		'Commoner': {
			'data-img': 'https://drive.google.com/file/d/1H-5cCt03oIB43CnhmdaHM6P2Aw8T2n60/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1H-5cCt03oIB43CnhmdaHM6P2Aw8T2n60/view?usp=sharing',
				'https://drive.google.com/file/d/14sNpLcJlzOfL4A5Qb_zdrYmOTZk51GTM/view?usp=sharing',
				'https://i.pinimg.com/564x/fa/93/fb/fa93fbf94a90d2068af62b5a34b48d2d.jpg',
				'https://i.pinimg.com/564x/b1/88/10/b18810e3a419fe6c9666ec64c67fdb4f.jpg',
				'https://i.pinimg.com/564x/b1/61/18/b16118b557ed8cd55a72631ff763fa97.jpg',
				'https://i.pinimg.com/564x/f7/6c/e5/f76ce511507ceb4be5003507c4b3190e.jpg',
				'https://i.pinimg.com/564x/d5/9b/e6/d59be622749ea74ccbc88485783e679c.jpg',
				'https://i.pinimg.com/564x/55/22/96/55229604ec385c8c1bf442a187a3aeeb.jpg',
				'https://i.pinimg.com/564x/da/56/f5/da56f50ba711df5b7c80e2fc240d9786.jpg',
				'https://i.pinimg.com/236x/62/45/8e/62458effd9b3901aa220954d50410988.jpg',
				'https://i.pinimg.com/236x/dc/39/e3/dc39e3e0edf1204d128565084146e221.jpg',
				'https://i.pinimg.com/236x/5a/13/5f/5a135f30617868eb35a78c0c268bd069.jpg',
				'https://i.pinimg.com/236x/6a/e2/51/6ae25147759cdf023dac43cdfeb68ef7.jpg',
				'https://i.pinimg.com/236x/d5/9b/e6/d59be622749ea74ccbc88485783e679c.jpg',
				'https://i.pinimg.com/236x/ec/24/81/ec2481a73c161cbbb70622e485bba1ae.jpg',
			]
		},
		'Dragonborn [F]': {
			'data-img': 'https://i.imgur.com/92aaNuq.png',
			'data-alternative-images': [
				'https://i.imgur.com/92aaNuq.png',
				'https://i.imgur.com/4WTK514.png',
				'https://i.imgur.com/vV4mfTo.png',
				'https://i.imgur.com/RdJKUBF.png',
			]
		},
		'Dragonborn [M]': {
			'data-img': 'https://i.imgur.com/0qQpdH6.png',
			'data-alternative-images': [
				'https://i.imgur.com/0qQpdH6.png',
				'https://i.imgur.com/EnMudqy.png',
				'https://i.imgur.com/ovnswTE.png',
				'https://i.imgur.com/29uuOXb.png',
				'https://i.imgur.com/Tjyc9Eq.png',
				'https://i.imgur.com/5k3RtNI.png',
				'https://i.imgur.com/YHOfDUc.png',
				'https://i.imgur.com/tQdEaQp.png',
				'https://i.imgur.com/bZZbhFd.png',
				'https://i.imgur.com/qpbahvt.png',
				'https://i.imgur.com/lSZIr0v.png',
				'https://i.imgur.com/Yxd8OuY.png',
				'https://i.imgur.com/Uha5043.png',
				'https://i.imgur.com/87kkYBT.png',
				'https://i.imgur.com/Mu4isFZ.png',
			]
		},
		'Drow [F]': {
			'data-img': 'https://i.imgur.com/lwPqseX.png',
			'data-alternative-images': [
				'https://i.imgur.com/lwPqseX.png',
				'https://i.imgur.com/cVaeAum.png',
				'https://i.imgur.com/2qHM12W.png',
				'https://i.imgur.com/apqxuLf.png',
				'https://i.imgur.com/OkdFTrq.png',
				'https://i.imgur.com/W4NtBsW.png',
				'https://i.imgur.com/yoIYDKO.png',
				'https://i.imgur.com/d4baR5O.png',
				'https://i.imgur.com/hpxtRYf.png',
				'https://i.imgur.com/SwxOZEX.png',
				'https://i.imgur.com/wGyXG6h.png',
				'https://i.imgur.com/ZolhnEc.png',
				'https://i.imgur.com/ROnLoAj.png',
				'https://i.imgur.com/PM09pdy.png',
				'https://i.imgur.com/6c8FF5q.png',
				'https://i.imgur.com/aqjKtH5.png',
				'https://i.imgur.com/v49Gd3r.png',
				'https://i.imgur.com/FHMszi4.png',
				'https://i.imgur.com/Lom5T9S.png',
			]
		},
		'Drow [M]': {
			'data-img': 'https://i.imgur.com/RgY5TkF.png',
			'data-alternative-images': [
				'https://i.imgur.com/RgY5TkF.png',
				'https://i.imgur.com/RsCAhou.png',
				'https://i.imgur.com/nwAzSyq.png',
				'https://i.imgur.com/aBlbyWo.png',
				'https://i.imgur.com/jEBw3ta.png',
				'https://i.imgur.com/oXyKmyK.png',
				'https://i.imgur.com/4BKZMqc.png',
				'https://i.imgur.com/8TcrJ88.png',
				'https://i.imgur.com/jCWJC1V.png',
				'https://i.imgur.com/WbWzpGq.png',
				'https://i.imgur.com/O6ui3WV.png',
				'https://i.imgur.com/Qr8TXfP.png',
				'https://i.imgur.com/9NuWJG6.png',
				'https://i.imgur.com/2LwVTUr.png',
			]
		},
		'Dwarf [F]': {
			'data-img': 'https://i.imgur.com/4Xuzbp6.png',
			'data-alternative-images': [
				'https://i.imgur.com/4Xuzbp6.png',
				'https://i.imgur.com/AmuvYtQ.png',
				'https://i.imgur.com/ZJvqWHQ.png',
				'https://i.imgur.com/eiWM0V7.png',
				'https://i.imgur.com/UED8IzA.png',
				'https://i.imgur.com/BwDRKyr.png',
			]
		},
		'Dwarf [M]': {
			'data-img': 'https://i.imgur.com/T6K1v8s.png',
			'data-alternative-images': [
				'https://i.imgur.com/T6K1v8s.png',
				'https://i.imgur.com/7xgLl17.png',
				'https://i.imgur.com/zO45eax.png',
				'https://i.imgur.com/w7KIJiI.png',
				'https://i.imgur.com/G9iZhpX.png',
				'https://i.imgur.com/F2hwQHB.png',
				'https://i.imgur.com/eamn3uD.png',
				'https://i.imgur.com/BSg4egK.png',
				'https://i.imgur.com/WRS4HKH.png',
				'https://i.imgur.com/G6aLVWI.png',
				'https://i.imgur.com/iSz72pl.png',
				'https://i.imgur.com/04X94ln.png',
				'https://i.imgur.com/F5kRG9O.png',
				'https://i.imgur.com/kANojx5.png',
				'https://i.imgur.com/SPQXGob.png',
				'https://i.imgur.com/jhVxT3w.png',
				'https://i.imgur.com/usObgvL.png',
				'https://i.imgur.com/4LUdLCx.png',
				'https://i.imgur.com/78ZtTUn.png',
			]
		},
		'Elf [F]': {
			'data-img': 'https://i.imgur.com/5brExHK.png',
			'data-alternative-images': [
				'https://i.imgur.com/5brExHK.png',
				'https://i.imgur.com/97Ssvg7.png',
				'https://i.imgur.com/Ql7WS0c.png',
				'https://i.imgur.com/vv4dBMN.png',
				'https://i.imgur.com/RBJ0P2K.png',
				'https://i.imgur.com/BVyZapA.png',
				'https://i.imgur.com/LyGbTHB.png',
				'https://i.imgur.com/MvxHbId.png',
				'https://i.imgur.com/S2taBOJ.png',
				'https://i.imgur.com/gbu9vUX.png',
				'https://i.imgur.com/6tSIQyq.png',
				'https://i.imgur.com/Y4d6rzn.png',
				'https://i.imgur.com/mo6XKpV.png',
				'https://i.imgur.com/RdTPLng.png',
				'https://i.imgur.com/CBwlgMF.png',
				'https://i.imgur.com/8n7IpwR.png',
				'https://i.imgur.com/rGbRzLw.png',
				'https://i.imgur.com/2Lglcip.png',
			]
		},
		'Elf [M]': {
			'data-img': 'https://i.imgur.com/KhyErAR.png',
			'data-alternative-images': [
				'https://i.imgur.com/KhyErAR.png',
				'https://i.imgur.com/bh9ZIeg.png',
				'https://i.imgur.com/K8U1b0h.png',
				'https://i.imgur.com/T3LBvjm.png',
				'https://i.imgur.com/06A68du.png',
				'https://i.imgur.com/DF1dSy7.png',
				'https://i.imgur.com/lG3wpol.png',
				'https://i.imgur.com/JC0VwYz.png',
				'https://i.imgur.com/iNaGb82.png',
				'https://i.imgur.com/w4rZdMx.png',
				'https://i.imgur.com/Eagxsqn.png',
				'https://i.imgur.com/PN7rm5K.png',
				'https://i.imgur.com/vkEGS5t.png',
				'https://i.imgur.com/5cUJo1X.png',
				'https://i.imgur.com/36nKnjL.png',
				'https://i.imgur.com/zzVxVGA.png',
				'https://i.imgur.com/f24uQF7.png',
				'https://i.imgur.com/2d2apvN.png',
				'https://i.imgur.com/ukdo8ds.png',
				'https://i.imgur.com/F9r9k3P.png',
				'https://i.imgur.com/dH30PNn.png',
				'https://i.imgur.com/9zg0eK8.png',
				'https://i.imgur.com/xQ0uII4.png',
				'https://i.imgur.com/Yt6osn6.png',
				'https://i.imgur.com/bNdE7DR.png',
				'https://i.imgur.com/AF3fv3C.png',
				'https://i.imgur.com/j3aX15i.png',
				'https://i.imgur.com/X1GP2WM.png',
				'https://i.imgur.com/v5FHlGi.png',
				'https://i.imgur.com/LfbJzvb.png',
				'https://i.imgur.com/V0rwmIX.png',
				'https://i.imgur.com/hqSP2Rs.png',
				'https://i.imgur.com/MNUuxZj.png',
				'https://i.imgur.com/dl8Vf71.png',
				'https://i.imgur.com/wSofg8Z.png',
				'https://i.imgur.com/mxXCnY1.png',
				'https://i.imgur.com/uwQOjqz.png',
				'https://i.imgur.com/d8FvdaA.png',
				'https://i.imgur.com/b3n8zEv.png',
				'https://i.imgur.com/aiHUW1S.png',
				'https://i.imgur.com/685hEZP.png',
				'https://i.imgur.com/bO5teIc.png',
				'https://i.imgur.com/4sbNTs1.png',
				'https://i.imgur.com/x5PsGUD.png',
			]
		},
		'Genasi': {
			'data-img': 'https://i.imgur.com/YnlG0US.png',
			'data-alternative-images': [
				'https://i.imgur.com/YnlG0US.png',
				'https://i.imgur.com/6TrSNc8.png',
				'https://i.imgur.com/VFn3KwT.png',
				'https://i.imgur.com/B1pH2vd.png',
				'https://i.imgur.com/m9HfCRo.png',
				'https://i.imgur.com/LN9r5Qq.png',
			]
		},
		'Guard [M]': {
			'data-img': 'https://drive.google.com/file/d/1C9ghQrfHckKPOMEHdmStaN47y0OXUPZ9/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1C9ghQrfHckKPOMEHdmStaN47y0OXUPZ9/view?usp=sharing'
			]
		},
		'Human [F]': {
			'data-img': 'https://i.imgur.com/NjP2sGL.png',
			'data-alternative-images': [
				'https://i.imgur.com/NjP2sGL.png',
				'https://i.imgur.com/H8Q36Zh.png',
				'https://i.imgur.com/RZq8SBK.png',
				'https://i.imgur.com/HHwopfD.png',
				'https://i.imgur.com/XqxVZmK.png',
				'https://i.imgur.com/CPAfuWB.png',
				'https://i.imgur.com/74bpcvT.png',
				'https://i.imgur.com/urg9Qhh.png',
				'https://i.imgur.com/t4yQcY9.png',
				'https://i.imgur.com/eymbYs8.png',
				'https://i.imgur.com/HOgBuYA.png',
				'https://i.imgur.com/FofhAaY.png',
				'https://i.imgur.com/ftlyRz6.png',
				'https://i.imgur.com/ufdYpaw.png',
				'https://i.imgur.com/PZ0UHJV.png',
				'https://i.imgur.com/6Ha5aDY.png',
				'https://i.imgur.com/DOnKbPL.png',
				'https://i.imgur.com/lbxFV6I.png',
				'https://i.imgur.com/2U9nwqu.png',
				'https://i.imgur.com/KcIaDqG.png',
				'https://i.imgur.com/NDNovgG.png',
				'https://i.imgur.com/RZkpx3l.png',
				'https://i.imgur.com/fZKrYaJ.png',
				'https://i.imgur.com/AuXrxtN.png',
				'https://i.imgur.com/tG53u3r.png',
				'https://i.imgur.com/9emKSJI.png',
			]
		},
		'Human [M]': {
			'data-img': 'https://i.imgur.com/vyeBFvg.png',
			'data-alternative-images': [
				'https://i.imgur.com/vyeBFvg.png',
				'https://i.imgur.com/iicVOSh.png',
				'https://i.imgur.com/RXQvDzB.png',
				'https://i.imgur.com/yMm3znX.png',
				'https://i.imgur.com/ZLYlstS.png',
				'https://i.imgur.com/E4aNjka.png',
				'https://i.imgur.com/sJodY4T.png',
				'https://i.imgur.com/cfsFqZk.png',
				'https://i.imgur.com/XdXU7mn.png',
				'https://i.imgur.com/GcNRFqx.png',
				'https://i.imgur.com/zVfhSCK.png',
				'https://i.imgur.com/0Hz1O3A.png',
				'https://i.imgur.com/nEh1ufo.png',
				'https://i.imgur.com/6XEUaP5.png',
				'https://i.imgur.com/VSU5NHE.png',
				'https://i.imgur.com/rYyd1h2.png',
				'https://i.imgur.com/07ffel4.png',
				'https://i.imgur.com/pyXlYqe.png',
				'https://i.imgur.com/KS2Hybd.png',
				'https://i.imgur.com/T6v1q7T.png',
				'https://i.imgur.com/juJzfQr.png',
				'https://i.imgur.com/RGzc7aD.png',
				'https://i.imgur.com/9J2iKvp.png',
				'https://i.imgur.com/2SaSS0Y.png',
				'https://i.imgur.com/jJ4c6ba.png',
				'https://i.imgur.com/k7Wx4mJ.png',
				'https://i.imgur.com/Vo1U9cK.png',
				'https://i.imgur.com/LVWkKVI.png',
				'https://i.imgur.com/yMMA82P.png',
				'https://i.imgur.com/f0N2oJa.png',
				'https://i.imgur.com/XJR4m0s.png',
				'https://i.imgur.com/8BKKghq.png',
				'https://i.imgur.com/FBPr0Qx.png',
				'https://i.imgur.com/zPJVZV9.png',
				'https://i.imgur.com/Fxnv4ze.png',
				'https://i.imgur.com/D3MfkZH.png',
				'https://i.imgur.com/fXa8rTq.png',
				'https://i.imgur.com/azyGhw3.png',
				'https://i.imgur.com/QmmV63Y.png',
				'https://i.imgur.com/r84pZVU.png',
				'https://i.imgur.com/qQKIKnR.png',
				'https://i.imgur.com/cDq8Vsr.png',
				'https://i.imgur.com/CbANiCZ.png',
				'https://i.imgur.com/roOhEoe.png',
				'https://i.imgur.com/2cLWc3p.png',
				'https://i.imgur.com/BgvoUWh.png',
				'https://i.imgur.com/PXEx15g.png',
				'https://i.imgur.com/GlG30ko.png',
				'https://i.imgur.com/MilamyO.png',
				'https://i.imgur.com/fnmpif1.png',
				'https://i.imgur.com/LxSkBCv.png',
				'https://i.imgur.com/BDWVEoG.png',
				'https://i.imgur.com/H8gIrL2.png',
				'https://i.imgur.com/Kz31l7I.png',
				'https://i.imgur.com/URuYHUf.png',
				'https://i.imgur.com/jpYQQCi.png',
				'https://i.imgur.com/onBgm22.png',
				'https://i.imgur.com/s86MIgN.png',
				'https://i.imgur.com/AW2altj.png',
				'https://i.imgur.com/gGag3hL.png',
				'https://i.imgur.com/C184k7z.png',
				'https://i.imgur.com/Q2EL6Zo.png',
				'https://i.imgur.com/AqOra0V.png',
				'https://i.imgur.com/NRowLmi.png',
				'https://i.imgur.com/47levai.png',
				'https://i.imgur.com/yDhhssO.png',
				'https://i.imgur.com/1J3nNHm.png',
				'https://i.imgur.com/S1uJBLa.png',
				'https://i.imgur.com/QT918eT.png',
				'https://i.imgur.com/FFLNXSA.png',
				'https://i.imgur.com/98mmYIW.png',
				'https://i.imgur.com/xi7maaE.png',
				'https://i.imgur.com/XBzgh8w.png',
				'https://i.imgur.com/pFW96Y2.png',
				'https://i.imgur.com/d1Cnrja.png',
				'https://i.imgur.com/fHSoonu.png',
				'https://i.imgur.com/UltpGWb.png',
				'https://i.imgur.com/wRUadat.png',
				'https://i.imgur.com/MvMSm3r.png',
				'https://i.imgur.com/eMfk7Zx.png',
				'https://i.imgur.com/yMNo6I9.png',
				'https://i.imgur.com/qjGsNn7.png',
				'https://i.imgur.com/JnJiGoa.png',
				'https://i.imgur.com/ZTSWn3Y.png',
				'https://i.imgur.com/v4F4gjg.png',
				'https://i.imgur.com/gJ9XBJI.png',
				'https://i.imgur.com/D7tMAL2.png',
				'https://i.imgur.com/hEQxRZy.png',
				'https://i.imgur.com/4RZiadV.png',
				'https://i.imgur.com/NYZJ8xP.png',
				'https://i.imgur.com/alANUDw.png',
				'https://i.imgur.com/3pxBGbD.png',
				'https://i.imgur.com/DHfRth2.png',
				'https://i.imgur.com/1bX4Qln.png',
				'https://i.imgur.com/0rzf1SN.png',
				'https://i.imgur.com/DFP9CIA.png',
				'https://i.imgur.com/fBh4m9C.png',
				'https://i.imgur.com/JqhtEZ0.png',
				'https://i.imgur.com/6l2RDlv.png',
				'https://i.imgur.com/FZmdqsr.png',
			]
		},
		'Maid [F]': {
			'data-img': 'https://drive.google.com/file/d/1wB5yKNKQ5dqkLhvWA5UZybLBBTDu-57c/view?usp=sharing',
			'data-alternative-images': [
				'https://drive.google.com/file/d/1wB5yKNKQ5dqkLhvWA5UZybLBBTDu-57c/view?usp=sharing'
			]
		},
		'Orc [F]': {
			'data-img': 'https://i.imgur.com/gmUUKun.png',
			'data-alternative-images': [
				'https://i.imgur.com/gmUUKun.png',
				'https://i.imgur.com/L0lLPWH.png',
				'https://i.imgur.com/Pwpr4Lp.png',
				'https://i.imgur.com/Zz9cnLt.png',
			]
		},
		'Orc [M]': {
			'data-img': 'https://i.imgur.com/4pWxSUn.png',
			'data-alternative-images': [
				'https://i.imgur.com/4pWxSUn.png',
				'https://i.imgur.com/OCrXvMz.png',
				'https://i.imgur.com/DcDsPj1.png',
				'https://i.imgur.com/mSZB6Xi.png',
				'https://i.imgur.com/BjgMrNq.png',
				'https://i.imgur.com/PSoXLYT.png',
				'https://i.imgur.com/W27Ad8q.png',
				'https://i.imgur.com/NChSGAp.png',
				'https://i.imgur.com/l3AOJfN.png',
				'https://i.imgur.com/sKQLsz5.png',
				'https://i.imgur.com/i1taIwb.png',
			]
		},
		'Tiefling [F]': {
			'data-img': 'https://i.imgur.com/r6fKPlI.png',
			'data-alternative-images': [
				'https://i.imgur.com/r6fKPlI.png',
				'https://i.imgur.com/gbs56aT.png',
				'https://i.imgur.com/LL8SD3k.png',
				'https://i.imgur.com/7gBPY82.png',
				'https://i.imgur.com/YjAMYM1.png',
				'https://i.imgur.com/dP9wszv.png',
				'https://i.imgur.com/HtsCPgu.png',
				'https://i.imgur.com/n2nb2NL.png',
				'https://i.imgur.com/STNSgme.png',
				'https://i.imgur.com/4iZmAAl.png',
				'https://i.imgur.com/LcPOA39.png',
				'https://i.imgur.com/xDTDx7I.png',
				'https://i.imgur.com/PyecEQG.png',
				'https://i.imgur.com/jRK8fZ6.png',
				'https://i.imgur.com/gPK3Qz7.png',
				'https://i.imgur.com/XwKL0NN.png',
				'https://i.imgur.com/rYc2U8J.png',
				'https://i.imgur.com/jHI0pdZ.png',
			]
		},
		'Tiefling [M]': {
			'data-img': 'https://i.imgur.com/iLKRQF5.png',
			'data-alternative-images': [
				'https://i.imgur.com/iLKRQF5.png',
				'https://i.imgur.com/H6EYE4b.png',
				'https://i.imgur.com/0lzHtWi.png',
				'https://i.imgur.com/6zcM3U9.png',
				'https://i.imgur.com/vLPCfzf.png',
				'https://i.imgur.com/pwuN7KB.png',
				'https://i.imgur.com/8GsL6N4.png',
				'https://i.imgur.com/YKFLCMO.png',
				'https://i.imgur.com/J5FescQ.png',
				'https://i.imgur.com/LHbk4bR.png',
				'https://i.imgur.com/YGs9gP0.png',
			]
		},
		'Warforged': {
			'data-img': 'https://i.imgur.com/N5Nvgkw.png',
			'data-alternative-images': [
				'https://i.imgur.com/N5Nvgkw.png',
				'https://i.imgur.com/8K3HZZJ.png',
				'https://i.imgur.com/KrYnmri.png',
				'https://i.imgur.com/JtyrFHx.png',
				'https://i.imgur.com/ApJMypw.png',
				'https://i.imgur.com/2p3WTci.png',
				'https://i.imgur.com/309BYqb.png',
				'https://i.imgur.com/r7my3b6.png',
				'https://i.imgur.com/SVo3VpB.png',
				'https://i.imgur.com/zrN3Vnt.png',
				'https://i.imgur.com/eKfE1AV.png',
			]
		}
	}
};


tokendata={
	folders:{},
};


function init_tokenmenu(){
	
	
	if(localStorage.getItem('CustomTokens') != null){
		tokendata=$.parseJSON(localStorage.getItem('CustomTokens'));
	}
	tokendata.folders['AboveVTT BUILTIN']=tokenbuiltin;

	let header = tokensPanel.header;
	header.append("<div class='panel-warning'>THIS IS AN EXPERIMENTAL FEATURE. DON'T START SPENDING HOURS ADDING TOKENS YET. YOU MAY LOSE THEM</div>");
	
	let backButton = $(`<div class="tokens-panel-back-button"><div>Back</div></div>`);
	header.append(backButton);
	backButton.click(function(event) {
		let previous = containing_folder_path(window.CURRENT_TOKEN_PATH);
		fill_tokenmenu(previous);
	});
	
	fill_tokenmenu("");

	let addTokenButton = $(`<button id="add-token-btn" class="sidebar-panel-footer-button">Add Token</button>`);
	addTokenButton.click(function(event) {
		let path = $(event.target).attr("data-folder-path");
		if (path === undefined) {
			path = "";
		}
		display_custom_token_form(path);
	});
	let addFolderButton = $(`<button id="add-folder-btn" class="sidebar-panel-footer-button">Add Folder</button>`);
	addFolderButton.click(function(event) {
		var newfoldername = prompt("Enter the name of the new folder");
		if (newfoldername == undefined || newfoldername == "") {
			// don't add folders when cancel is pressed or if they didn't enter a folder name at all
			return;
		}
		let path = window.CURRENT_TOKEN_PATH;
		if (path === undefined) {
			path = "";
		}
		let folder = convert_path(path);
		if(!folder.folders) {
			folder.folders = {};
		}
		folder.folders[newfoldername] = {};
		persist_customtokens();
		fill_tokenmenu(`${path}/${newfoldername}`);
	});

	let buttonWrapper = $(`<div class="sidebar-panel-footer-horizontal-wrapper"></div>`)
	buttonWrapper.append(addTokenButton);
	buttonWrapper.append(addFolderButton);
	tokensPanel.footer.append(buttonWrapper);

	register_token_row_context_menu();             // context menu for each row
	register_custom_monster_image_context_menu();  // context menu for images within the customization modal
}

function convert_path(path){
	var pieces=path.split("/");
	var current=tokendata;
	
	for(var i=0;i<pieces.length;i++){
		if(pieces[i]=="")
			continue;
		current=current.folders[pieces[i]];
	}
	return current;
}

function fill_tokenmenu(path){
	console.log(`fill_tokenmenu ${path}`);
	if (path === undefined) {
		path = "";
	}
	window.CURRENT_TOKEN_PATH = path; // be careful using this. It should only be used for folder navigation
	let folder = convert_path(path);
	// $("#tokens-panel-data").empty();
	tokensPanel.body.empty();
	let footer = tokensPanel.footer;
	// TODO: consider storing current path on the tokensPanel object
	footer.find("#add-token-btn").attr("data-folder-path", path);
	footer.find("#add-token-btn").attr("data-folder-path", path);
	if (path == "") {
		tokensPanel.header.find(".tokens-panel-back-button").hide();
	} else {
		tokensPanel.header.find(".tokens-panel-back-button").show();
	}

	draw_custom_token_list(folder, path);
	
	if (is_builtin(path)) {
		// don't allow users to add tokens or folders inside the builtin folder
		tokensPanel.footer.hide();
	} else {
		tokensPanel.footer.show();
	}
}

function persist_customtokens(){
	tokendata.folders["AboveVTT BUILTIN"]={};
	localStorage.setItem("CustomTokens",JSON.stringify(tokendata));
	tokendata.folders["AboveVTT BUILTIN"]=tokenbuiltin;
}

function draw_custom_token_list(folder, path) {

	let list = $(`<div class="custom-token-list"></div>`);
	if (folder.folders) {
		for(let f in folder.folders) {
			let row = build_custom_token_row(f, window.EXTENSION_PATH + "assets/folder.svg", undefined, false);
			row.find(".custom-token-image-row-handle").remove(); // no drag handle on the right side of folders
			row.find(".custom-token-image-row-add svg").css("fill", "#fff");
			row.find(".custom-token-image-row-add").css("border", "#fff");
			row.find(".custom-token-image-row-add").prop("disabled", true);
			let currentFolderPath = path + "/" + f;
			row.click(function () {
				fill_tokenmenu(currentFolderPath);
			});
			row.attr('data-folder-name', f);
			row.attr('data-folder-path', path);
			list.append(row);
		}
	}

	if (folder.tokens) {
		for(let t in folder.tokens) {
			let token = folder.tokens[t]
			let name = token["data-name"];
			if (name == undefined) {
				name = t;
			}
			let imgSrc = token["data-img"];
			let tokenSize = token["data-token-size"];
			let subtitleText = "Small / Medium (5ft)";
			if (tokenSize != undefined) {
				switch (tokenSize) {
					case "custom": 
						subtitleText = "Custom (Xft)"; // figure this out
						break; 
					case 2: subtitleText = "Large (10ft)"; break;
					case 3: subtitleText = "Huge (15ft)"; break;
					case 4: subtitleText = "Gargantuan (20ft)"; break;
				}
			}
			let row = build_custom_token_row(name, imgSrc, subtitleText);
			for(prop in token){
				row.find(".custom-token-image-row-add").attr(prop, token[prop]);
			}
			row.find(".custom-token-image-row-add").attr("data-disablestat", true);
			row.find(".custom-token-image-row-add").attr("data-token-size", tokenSize);
			row.find(".custom-token-image-row-add").attr('data-tokendatapath', path);
			row.find(".custom-token-image-row-add").attr('data-tokendataname', t);
			row.find(".custom-token-image-row-add").click(function(event) {
				place_token_from_modal(path, t, false);
			});
	
			row.attr('data-tokendatapath', path);
			row.attr('data-tokendataname', t);
			row.find(".custom-token-image-row-handle").click(function() {
				display_custom_token_form(path, t, token);
			});
	
			list.append(row);
		}
	}

	let body = tokensPanel.body;
	body.empty();
	body.append(list);
}

function build_custom_token_row(name, imgSrc, subtitleText, enableDrag = true) {

	let row = $(`<div class="custom-token-image-row"></div>`);
	let rowItem = $(`<div class="custom-token-image-row-item"></div>`);
	row.append(rowItem);

	let imgHolder = $(`<div class="custom-token-image-row-img"></div>`);
	let img = $(`<img src="${parse_img(imgSrc)}" />`);
	imgHolder.append(img);

	let details = $(`<div class="custom-token-image-row-details"></div>`);
	let title = $(`<div class="custom-token-image-row-details-title">${name}</div>`);
	details.append(title);
	if (subtitleText != undefined) {
		let subtitle = $(`<div class="custom-token-image-row-details-subtitle">${subtitleText}</div>`);
		details.append(subtitle);
	}

	let addButton = $(`
		<button class="custom-token-image-row-add" title="${name}" data-name="${name}" data-img="${imgSrc}">
			<svg viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.2 10.8V18h3.6v-7.2H18V7.2h-7.2V0H7.2v7.2H0v3.6h7.2z"></path></svg>
		</button>
	`);
	let handle = $(`<div class="custom-token-image-row-handle"><svg class="monster-row__cell--drag-handle__icon" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 2a1 1 0 110 2H1a1 1 0 110-2h10zm0 6a1 1 0 110 2H1a1 1 0 110-2h10z"></path></svg></div>`);

	rowItem.append(imgHolder);
	rowItem.append(details);
	rowItem.append(addButton);
	rowItem.append(handle);

	if (enableDrag) {
		rowItem.draggable({
			appendTo: "#VTTWRAPPER",
			zIndex: 100000,
			cursorAt: {top: 0, left: 0},
			cancel: '.custom-token-image-row-handle',
			helper: function(event) {
				let helper = $(event.currentTarget).find(".custom-token-image-row-img img").clone();
				let addButton = $(event.currentTarget).find(".custom-token-image-row-add");
				let path = addButton.attr("data-tokendatapath");
				let name = addButton.attr("data-tokendataname");
				helper.attr("src", random_image_for_token(path, name));
				return helper;
			},
			start: function (event, ui) {
				console.log("row-item drag start");
				let addButton = $(event.currentTarget).find(".custom-token-image-row-add");
				let tokenSize = addButton.data('token-size');
				if (tokenSize === undefined) {
					tokenSize = 1;
				}
				let width = Math.round(window.CURRENT_SCENE_DATA.hpps) * tokenSize;
				let helperWidth = width / (1.0 / window.ZOOM);
				$(ui.helper).css('width', `${helperWidth}px`);
				$(this).draggable('instance').offset.click = {
					left: Math.floor(ui.helper.width() / 2),
					top: Math.floor(ui.helper.height() / 2)
				};
			},
			stop: function (event, ui) { 
				// place a token where this was dropped
				console.log("row-item drag stop");
				let src = $(ui.helper).attr("src");
				let addButton = $(event.target).find(".custom-token-image-row-add");
				let path = addButton.attr("data-tokendatapath");
				let name = addButton.attr("data-tokendataname");
				place_token_from_modal(path, name, event.shiftKey, src, event.pageX, event.pageY);
			}
		});
	}
	return row;
}


function register_token_row_context_menu() {

	// don't allow the context menu when right clicking on the add button since that adds a hidden token
	$(".custom-token-image-row").on("contextmenu", ".custom-token-image-row-add", function(event) {
		event.preventDefault();
		event.stopPropagation();
		// token_button uses target which will often be the svg inside of the button, but we want to use the button which will always be currentTarget
		let tokendatapath = $(event.currentTarget).attr("data-tokendatapath");
		let tokendataname = $(event.currentTarget).attr("data-tokendataname");
		if (tokendataname === undefined) {
			tokendataname = $(event.currentTarget).attr("data-name");
		}
		place_token_from_modal(tokendatapath, tokendataname, true);
	});

	$.contextMenu({
		selector: ".custom-token-image-row",
		build: function(element, e) {

			let items = {};
			
			let folderName = $(element).attr("data-folder-name");
			let isFolder = folderName !== undefined;
			
			let tokenAddButton = $(element).find(".custom-token-image-row-add");

			let path = "";
			if (isFolder) {
				path = $(element).attr("data-folder-path");
			} else {
				path = tokenAddButton.attr("data-tokendatapath");
			}
			if (path === undefined) {
				path = "";
			}
			let folder = convert_path(path);

			let tokenName = tokenAddButton.attr("data-tokendataname");
			if (tokenName === undefined) {
				tokenName = tokenAddButton.attr("data-name");
			}
			
			if (!isFolder) {
				// add token items

				items["place"] = {
					name: "Place Token",
					callback: function(itemKey, opt, originalEvent) {
						place_token_from_modal(path, tokenName, false);
					}
				};
				
				items["placeHidden"] = {
					name: "Place Hidden Token",
					callback: function(itemKey, opt, originalEvent) {
						place_token_from_modal(path, tokenName, true);
					}
				};

				items["copyUrl"] = {
					name: "Copy Url",
					callback: function(itemKey, opt, originalEvent) {
						let imgSrc = tokenAddButton.attr("data-img");
						copy_to_clipboard(imgSrc);
					}
				};

			} 

			// add delete menu option
			if (path.startsWith("/AboveVTT BUILTIN")) {
				items["no-delete"] = {
					name: "Folders and Tokens provided by AboveVTT cannot be edited or deleted",
					disabled: true
				};
			} else {

				items["edit"] = {
					name: "Edit",
					callback: function(itemKey, opt, originalEvent) {
						if (isFolder) {
							var newfoldername = prompt("Enter the name of the folder", folderName);
							if (newfoldername != undefined && newfoldername.length > 0) {
								if(!folder.folders) {
									folder.folders = {};
								}
								folder.folders[newfoldername] = folder.folders[folderName];
								delete folder.folders[folderName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						} else {
							display_custom_token_form(path, tokenName);
						}
					}
				};
	
				items["border"] = "---";
	
				// not a built in folder or token, add an option to delete
				items["delete"] = {
					name: "Delete",
					callback: function(itemKey, opt, originalEvent) {
						if (isFolder) {
							console.log(`delete selected; folderName = ${folderName}`);
							if (confirm(`Are you sure you want to delete the folder "${folderName}"? The folder and all tokens in it will be deleted. This cannot be undone.`)) {
								delete folder.folders[folderName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						} else {
							console.log(`delete selected; tokenName = ${tokenName}`);
							if (confirm(`Are you sure you want to delete the token "${tokenName}"? This cannot be undone.`)) {
								delete folder.tokens[tokenName];
								fill_tokenmenu(path);
								persist_customtokens();
							}
						}
					}
				};
			}
			return { items: items };
		}
	});
}

function is_builtin(path) {
	if (path === undefined) {
		console.warn("is_builtin was called without a path");
		return false;
	}
	return path.startsWith("/AboveVTT BUILTIN");
}

function display_custom_token_form(path, name, token) {

	// close any that are already open. This shouldn't be necessary, but it doesn't hurt just in case
	close_sidebar_modal();

	if (path === undefined) {
		console.warn("display_custom_token_form was called without a path");
		path = "";
	}
	let folder = convert_path(path);

	if (name !== undefined && token === undefined) {
		// we got a name, but not a token. Let's see if we can find a token that matches the name
		token = folder.tokens[name];
	}

	let sidebarPanel = new SidebarPanel("custom-token-customization-modal");
	display_sidebar_modal(sidebarPanel);

	let explanationText = "Enter a url at the bottom to create a new token.";
	let headerTitle = name === undefined ? "New Token" : name
	sidebarPanel.updateHeader(headerTitle, "", explanationText);

	if (token !== undefined) {
		explanationText = "When placing tokens, one of these images will be chosen at random. Right-click an image for more options.";
		migrate_token_image_data(token);
	}

	// add all of the tokens images to the body
	redraw_images_in_modal_body(sidebarPanel.body, path, name, token);

	if (!is_builtin(path)) {
		// only build the footer for custom tokens. Don't allow builtin tokens to be edited
		build_custom_token_form_footer(sidebarPanel, path, name, token)
	}

	update_modal_images(sidebarPanel, populate_token_from_form(sidebarPanel, token));
}

function build_custom_token_form_footer(sidebarPanel, path, name, token) {
	let footerText = token == undefined ? "Enter an Image Url" : "Add More Custom Images";
	const footerSubmit = function(imgUrl) {
		submit_custom_token_form(sidebarPanel, path);
	}

	let imageUrlInput = sidebarPanel.build_image_url_input(footerText, footerSubmit);

	let inputWrapper = sidebarPanel.inputWrapper;
	inputWrapper.append(imageUrlInput);

	let nameInput = $(`<input data-previous-name="${name}" title="token name" placeholder="my token name" name="addCustomName" type="text" style="width:100%" value="${name == undefined ? '' : name}" />`);
	nameInput.on('keyup', function(event) {
		if (event.key == "Enter") {
			submit_custom_token_form(sidebarPanel, path);
		}
	});

	// TODO: add a custom option and allow users to specify the size 			<option value="custom">Custom</option>
	let tokenSizeInput = $(`
		<select name="data-token-size">
			<option value="1">Small/Medium (5ft)</option>
			<option value="2">Large (10ft)</option>
			<option value="3">Huge (15ft)</option>
			<option value="4">Gargantuan (20ft)</option>
		</select>
	`);	
	let tokenSize = token == undefined ? undefined : token["data-token-size"];
	if (tokenSize != undefined) {
		if (tokenSize > 4) {
			tokenSizeInput.val("custom");
		} else {
			tokenSizeInput.val(`${tokenSize}`);
		}
	} else {
		tokenSizeInput.val("default");
	}

	let tokenTypeInput = $(`
		<select name="data-square">
			<option value="default">Default</option>
			<option value="round">Round</option>
			<option value="square">Square</option>
		</select>
	`);
	// this is explicitly looking for 
	let tokenType = token == undefined ? undefined : token["data-square"];
	// this is explicitly looking for true/false because the default value is undefined
	if (tokenType == true) {
		tokenTypeInput.val("square");
	} else if (tokenType == false) {
		tokenTypeInput.val("round");
	} else {
		tokenTypeInput.val("default");
	}

	let hideBorderInput = $(`
		<select name="data-disableborder">
			<option value="default">Default</option>
			<option value="enabled">Border</option>
			<option value="disabled">No Border</option>
		</select>
	`);
	let hideBorder = token == undefined ? undefined : token["data-disableborder"];
	// this is explicitly looking for true/false because the default value is undefined
	if (hideBorder == true) {
		hideBorderInput.val("disabled");
	} else if (hideBorder == false) {
		hideBorderInput.val("enabled");
	} else {
		hideBorderInput.val("default");
	}

	let aspectRatioInput = $(`
		<select name="data-legacyaspectratio">
			<option value="default">Default</option>
			<option value="maintain">Maintain</option>
			<option value="legacy">Stretch</option>
		</select>
	`);
	let legacyaspectratio = token == undefined ? undefined : token["data-legacyaspectratio"];
	// this is explicitly looking for true/false because the default value is undefined
	if (legacyaspectratio == true) {
		aspectRatioInput.val("legacy");
	} else if (legacyaspectratio == false) {
		aspectRatioInput.val("maintain");
	} else {
		aspectRatioInput.val("default");
	}

	let saveButton = $(`<button class="sidebar-panel-footer-button" style="width:100%;padding:8px;margin-top:8px;margin-left:0px;">Save Token</button>`);
	saveButton.click(function(event) {
		submit_custom_token_form(sidebarPanel, path);
		close_sidebar_modal();
	});

	const onChange = function() {
		submit_custom_token_form(sidebarPanel, path);
	}
	tokenSizeInput.change(onChange);
	tokenTypeInput.change(onChange);
	hideBorderInput.change(onChange);
	aspectRatioInput.change(onChange);

	inputWrapper.append($(`<div class="token-image-modal-footer-title" style="width:100%;padding-left:0px">Token Name</div>`));
	inputWrapper.append(nameInput);
	inputWrapper.append(build_select_input("Token Size", tokenSizeInput));
	inputWrapper.append(`<div class="sidebar-panel-header-explanation" style="padding-bottom:6px;">The following will override global settings for this token. Global settings can be changed in the settings tab.</div>`)
	inputWrapper.append(build_select_input("Token Shape", tokenTypeInput));        // adds class token-round
	inputWrapper.append(build_select_input("Border Visibility", hideBorderInput)); // sets border-width: 4
	inputWrapper.append(build_select_input("Aspect Ratio", aspectRatioInput));     // adds class preserve-aspect-ratio
	inputWrapper.append(saveButton);

}

function populate_token_from_form(sidebarPanel, token) {
	if (token == undefined) {
		token = {};
	}
	if (sidebarPanel === undefined) {
		console.warn("populate_token_from_form was called without a sidebarPanel");
		return token;
	}

	let inputWrapper = sidebarPanel.inputWrapper;
	if (inputWrapper.length == 0) {
		// we're probably inside a builtin directory. We remove the footer to avoid users mucking with builtin data, and therefore don't have a form to populate from
		return token;
	}

	let tokenSize = inputWrapper.find(`select[name='data-token-size']`)[0].value;
	if (tokenSize == "custom") {
		// TODO: this
	} else {
		let tokenSizeNumber = parseInt(tokenSize);
		if (tokenSizeNumber !== undefined && typeof tokenSizeNumber === 'number') {
			token['data-token-size'] = tokenSizeNumber;
		} else {
			delete token['data-token-size'];
		}
	}

	let tokenType = inputWrapper.find(`select[name='data-square']`)[0].value;
	switch (tokenType) {
		case "square":
			token['data-square'] = true;
			break;
		case "round": 
			token['data-square'] = false;
			break;
		default:
			delete token['data-square'];
	}

	let hideBorder = inputWrapper.find(`select[name='data-disableborder']`)[0].value;
	switch (hideBorder) {
		case "disabled": 
			token['data-disableborder'] = true;
			break;
		case "enabled":
			token['data-disableborder'] = false;
			break;
		default:
			delete token['data-disableborder'];
	}

	let aspectRatio = inputWrapper.find(`select[name='data-legacyaspectratio']`)[0].value;
	switch (aspectRatio) {
		case "legacy": 
			token['data-legacyaspectratio'] = true;
			break;
		case "maintain":
			token['data-legacyaspectratio'] = false;
			break;
		default:
			delete token['data-legacyaspectratio'];
	}

	return token;
}

function submit_custom_token_form(sidebarPanel, path) {
	if (sidebarPanel === undefined) {
		console.warn("submit_custom_token_form was called without a sidebarPanel");
		return;
	}	
	if (path === undefined) {
		console.warn("submit_custom_token_form was called without a path");
		path = "";
	}
	let folder = convert_path(path);
	if(!folder.tokens) {
		folder.tokens = {};
	}

	let inputWrapper = sidebarPanel.inputWrapper;
	
	let nameInput = inputWrapper.find(`input[name='addCustomName']`)[0];
	let name = nameInput.value;
	if (name === undefined || name.length == 0) {
		console.warn("not saving a token with no name");
		return;
	}
	// if the token already exists, the name will be stored here. Use it to find the token object as well as handling name changes
	let previousName = $(nameInput).attr("data-previous-name");
	let imageInput = inputWrapper.find(`input[name='addCustomImage']`)[0];
	let imageUrl = imageInput.value;

	if(imageUrl.startsWith("data:")){
		alert("You cannot use urls starting with data:");
		return;
	}

	let token;
	if (previousName != undefined && previousName.length > 0 && previousName != 'undefined') {
		token = folder.tokens[previousName];
	}

	let isNewToken = token === undefined;
	let didRename = previousName != name;

	if (didRename) {
		if (folder.tokens[name] !== undefined) {
			// prevent them from overwriting an existing token
			alert(`There is already a token named "${name}"`);
			return;
		}
		// the user renamed this token. Remove the token at the old name. We'll be saving under the new name shortly.
		delete folder.tokens[previousName];
	}

	if (isNewToken) {
		token = { 'data-img': imageUrl };
	}

	if (token['data-alternative-images'] == undefined) {
		token['data-alternative-images'] = [];
	}

	if (imageUrl != undefined && imageUrl.length > 0 && token['data-alternative-images'].at(-1) != imageUrl) {
		token['data-alternative-images'].push(imageUrl);
	}

	folder.tokens[name] = populate_token_from_form(sidebarPanel, token);
	persist_customtokens();
	
	if (isNewToken || didRename) {
		// redraw the entire modal so we get all the updated information about the token. 
		// if you submit the same name twice in a row, we seem to get a cached DOM element for some reason
		// TODO: figure out everything that needs to be updated, and do that instead of redrawing the entire thing
		display_custom_token_form(path, name, token);
	} else {
		redraw_images_in_modal_body(sidebarPanel.body, path, name, token);
	}
	// just reload the body instead of the entire modal
	
	fill_tokenmenu(path);
	update_modal_images(sidebarPanel, folder.tokens[name]);
}

function update_modal_images(sidebarPanel, token) {

	if (token === undefined) {
		console.warn("update_modal_images was called without a token");
		return;
	}

	let items = sidebarPanel.body.find(".custom-token-image-item");

	// use token override if it exists, else fall back to global setting
	let tokenSquareSetting = token["data-square"];
	let globalSquareSetting = window.TOKEN_SETTINGS["square"];
	if (tokenSquareSetting == true) {
		items.find("img").removeClass("token-round");
	} else if (tokenSquareSetting == false) {
		items.find("img").addClass("token-round");
	} else if (globalSquareSetting == true) {
		items.find("img").removeClass("token-round");
	} else {
		items.find("img").addClass("token-round");
	}

	let tokenBorderSetting = token["data-disableborder"];
	let globalBorderSetting = window.TOKEN_SETTINGS["disableborder"];
	if (tokenBorderSetting == true) {
		items.find("img").css("border", "0px solid #000")
	} else if (tokenBorderSetting == false) {
		items.find("img").css("border", "4px solid #000")
	} else if (globalBorderSetting == true) {
		items.find("img").css("border", "0px solid #000")
	} else {
		items.find("img").css("border", "4px solid #000")
	}

	let tokenLegacyaspectratio = token["data-legacyaspectratio"];
	let globalLegacyaspectratio = window.TOKEN_SETTINGS["legacyaspectratio"];
	if (tokenLegacyaspectratio == true) {
		items.find("img").removeClass("preserve-aspect-ratio");
	} else if (tokenLegacyaspectratio == false) {
		items.find("img").addClass("preserve-aspect-ratio");
	} else if (globalLegacyaspectratio == true) {
		items.find("img").removeClass("preserve-aspect-ratio");
	} else {
		items.find("img").addClass("preserve-aspect-ratio");
	}

	items.attr("data-token-size", token["data-token-size"]);
}

function random_image_for_token(path, name) {
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to find a token with name ${name}, and path ${path}`);
		return "";
	}
	let images = token['data-alternative-images'];
	if (images === undefined || images.length == 0) {
		images = [ token['data-img'] ];
	}
	let randomIndex = getRandomInt(0, images.length);
	let randomImage = images[randomIndex];
	return parse_img(randomImage);
}

function place_token_from_modal(path, name, hidden, specificImage, eventPageX, eventPageY) {
	if (path === undefined) {
		path = find_best_path(name);
	}
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to place a token with name ${name}, and path ${path}`);
		return;
	}

	let options = {
		name: name,
		square: token['data-square'],
		disableborder: token['data-disableborder'],
		legacyaspectratio: token['data-legacyaspectratio'],
		hidden: hidden,
		tokendatapath: path,
		tokendataname: name,
		disablestat: true
	};

	if (specificImage === undefined) {
		options.imgsrc = random_image_for_token(path, name);
	} else {
		options.imgsrc = specificImage;
	}

	// set reasonable defaults
	if (options.square === undefined) {
		options.square = window.TOKEN_SETTINGS["square"];
		if (options.square == undefined) {
			options.square = false;
		}
	}
	if (options.disableborder === undefined) {
		options.disableborder = window.TOKEN_SETTINGS["disableborder"];
		if (options.disableborder == undefined) {
			options.disableborder = false;
		}
	}
	if (options.legacyaspectratio === undefined) {
		options.legacyaspectratio = window.TOKEN_SETTINGS["legacyaspectratio"];
		if (options.legacyaspectratio == undefined) {
			options.legacyaspectratio = false;
		}
	}

	let tokenSizeSetting = token['data-token-size'];
	let tokenSize = parseInt(tokenSizeSetting);
	if (tokenSizeSetting === undefined || typeof tokenSizeSetting !== 'number') {
		tokenSize = 1;
		// TODO: handle custom sizes
	}
	options.tokenSize = tokenSize;

	if (eventPageX === undefined || eventPageY === undefined) {
		place_token_in_center_of_map(options);
	} else {
		place_token_under_cursor(options, eventPageX, eventPageY);
	}
}

function display_placed_token_customization_modal(placedToken) {
	if (placedToken === undefined) {
		console.warn("Attempted to call display_placed_token_customization_modal without a token");
		return;
	}

	// close any that are already open. This shouldn't be necessary, but it doesn't hurt just in case
	close_sidebar_modal();

	let monsterId = placedToken.options.monster;
	if (monsterId !== undefined) {
		window.StatHandler.getStat(monsterId, function(stat) {
			display_monster_customization_modal(placedToken, monsterId, placedToken.options.name, stat.data.avatarUrl);
		});
		return;
	}

	let tokenDataPath = placedToken.options.tokendatapath;
	let tokenDataName = placedToken.options.tokendataname !== undefined ? placedToken.options.tokendataname : placedToken.options.name;

	if (tokenDataPath === undefined) {
		let matchingPaths = find_token_paths(tokenDataName);
		if (matchingPaths.length == 1) {
			tokenDataPath = matchingPaths[0];
		} else {
			console.warn(`Failed to find a matching path for token with name ${tokenDataName}`);


			// TODO: build token association feature here


		}
	}

	let savedTokenData = find_token_at_path(tokenDataPath, tokenDataName);
	if (savedTokenData !== undefined) {
		if (savedTokenData['data-alternative-images'] === undefined) {
			savedTokenData['data-alternative-images'] = [];
		}
	} else {
		console.warn(`Failed to find a token with path ${tokenDataPath}`);
	}

	// build the modal header
	let explanationText = "Click an image below to update your token or enter a new image URL at the bottom.";
	if (savedTokenData === undefined) {
		explanationText = "Enter a new image URL at the bottom.";
	}

	let sidebarPanel = new SidebarPanel("custom-token-customization-modal");
	display_sidebar_modal(sidebarPanel);
	sidebarPanel.updateHeader(placedToken.options.name, "", explanationText);

	// configure the modal body
	let modalBody = sidebarPanel.body;
	// add all of the tokens images to the body
	redraw_images_in_modal_body(modalBody, tokenDataPath, tokenDataName, savedTokenData, placedToken);

	// build the modal footer
	const add_token_customization_image = function(imageUrl) {
		if(imageUrl.startsWith("data:")){
			alert("You cannot use urls starting with data:");
			return;
		}

		if (savedTokenData === undefined) {
			// this is an unassociated token. Blindly swap the url and close the modal
			placedToken.options.imgsrc = parse_img(imageUrl);
			close_sidebar_modal();
			placedToken.place_sync_persist();
		} else {
			let tokenDataName = placedToken.options.tokendataname !== undefined ? placedToken.options.tokendataname : placedToken.options.name;
			add_image_to_token_data(imageUrl, tokenDataPath, tokenDataName); // save the image
			redraw_images_in_modal_body(modalBody, tokenDataPath, tokenDataName, savedTokenData, placedToken);
		}
	};
	
	let imageInput = sidebarPanel.build_image_url_input("Enter a new image URL", add_token_customization_image);
	imageInput.find(`.token-image-modal-add-button`).remove();
	sidebarPanel.inputWrapper.append(imageInput);

	// allow them to use the new url for the placed token without saving the url for all future monsters
	let onlyForThisTokenButton = $(`<button class="sidebar-panel-footer-button" title="This url will be used for this token only. New tokens will continue to use the images shown above.">Set for this token only</button>`);
	onlyForThisTokenButton.click(function(event) {
		let imageUrl = $(`input[name='addCustomImage']`)[0].value;
		if (imageUrl != undefined && imageUrl.length > 0) {
			placedToken.options.imgsrc = parse_img(imageUrl);
			close_sidebar_modal();
			placedToken.place_sync_persist();
		}
	});
	sidebarPanel.inputWrapper.append(onlyForThisTokenButton);

	if (savedTokenData !== undefined && !is_builtin(tokenDataPath)) {
		// Only show the add for all button if the placed token has been associated with a saved token object. We can't save what we don't know about
		let addForAllButton = $(`<button class="sidebar-panel-footer-button" title="New tokens will use this new image. If you have more than one image, one will be chosen at random when you place a new token.">Add for all future tokens</button>`);
		addForAllButton.click(function(event) {
			let imageUrl = $(`input[name='addCustomImage']`)[0].value;
			if (imageUrl != undefined && imageUrl.length > 0) {
				add_image_to_token_data(imageUrl, tokenDataPath, placedToken.options.name);
				display_placed_token_customization_modal(placedToken);	
			}
		});
		sidebarPanel.inputWrapper.append(addForAllButton);
	}

	sidebarPanel.inputWrapper.append($(`<div class="sidebar-panel-header-explanation" style="padding:4px;">You can access this modal from the Tokens tab by clicking the button on the right side of the token row.</div>`));
	update_modal_images(sidebarPanel, savedTokenData);
}

function redraw_images_in_modal_body(modalBody, path, name, tokenData, placedToken) {
	if (tokenData === undefined) {
		// Don't display any images if we haven't associated a saved token yet. 
		// We don't want to give the impression that the user could interact with this image. 
		// Once the placed token has been associated with a saved token, then this will work as expected.
		return;
	}

	// clear it out before we fill it up
	modalBody.empty();
	
	let tokenSize = tokenData['data-token-size'];
	let dataImg = parse_img(tokenData['data-img']);

	// clone our images array instead of using a reference so we don't accidentally change the currently images for all tokens
	// we also need to parse and compare every image to know if we need to add the placedToken image
	let images = [];
	for (let i = 0; i < tokenData['data-alternative-images'].length; i++) {
		let parsedImage = parse_img(tokenData['data-alternative-images'][i]);
		images.push(parsedImage);
	}
	
	let indexOffset = 0;
	if (dataImg !== undefined && !images.includes(dataImg)) {
		// the main image somehow isn't in the list so put it at the front
		images.unshift(dataImg);
		indexOffset++;
	}

	if (placedToken !== undefined) {
		if (placedToken.options.tokenSize !== undefined) {
			tokenSize = placedToken.options.tokenSize;
		}
		if (placedToken.options.name !== undefined && placedToken.options.name != name) {
			name = placedToken.options.name;
		}
		let placedImg = parse_img(placedToken.options.imgsrc);
		if (placedImg !== undefined && !images.includes(placedImg)) {
			// the placedToken image has been changed by the user so put it at the front
			images.unshift(placedImg);
			indexOffset++;
		}
	}
	if (tokenSize === undefined) {
		tokenSize = 1;
	}

	
	for (let i = 0; i < images.length; i++) { 
		let imageUrl = parse_img(images[i]);
		let tokenDiv = build_custom_token_item(name, imageUrl, tokenSize, i - indexOffset);
		if (placedToken !== undefined) {
			// if they click this image, update the placedToken and close the modal
			tokenDiv.click(function() {
				placedToken.options.imgsrc = imageUrl;
				close_sidebar_modal();
				placedToken.place_sync_persist();
			});
			if (placedToken.options.tokendatapath !== undefined) {
				tokenDiv.attr("tokendatapath", placedToken.options.tokendatapath);
			} else {
				tokenDiv.attr("data-tokendatapath", path);
			}
			if (placedToken.options.tokendataname !== undefined) {
				tokenDiv.attr("data-tokendataname", placedToken.options.tokendataname);
			} else {
				tokenDiv.attr("data-tokendataname", name);	
			}
		} else {
			tokenDiv.attr("data-tokendatapath", path);
			tokenDiv.attr("data-tokendataname", name);
		}
		modalBody.append(tokenDiv);
	}
}

function find_token_paths(name) {

	let paths = [];

	const checkFolder = function(folder, currentPath) {
		if (folder == undefined) {
			// that's as deep as we can go in this folder
			return;
		}
		if (folder.tokens != undefined && folder.tokens[name] != undefined) {
			// fond at the currentPath so let's add it to the list
			paths.push(currentPath);
		}
		for(let folderName in folder.folders) {
			// found nested folders, let's look in those as well
			let folderObject = folder.folders[folderName];
			checkFolder(folderObject, `${currentPath}/${folderName}`);
		}
	};

	checkFolder(tokendata, "");

	return paths;
}

function find_best_path(name) {
	let matchingPaths = find_token_paths(name);
	if (matchingPaths !== undefined && matchingPaths.length == 1) {
		return matchingPaths[0];
	} else {
		console.warn(`find_best_path could not determine the best path for name: ${name}`);
		return undefined;
	}
}

function find_token_at_path(path, name) {
	if (path === undefined) {
		// This could be a token that was placed before this feature went live. try to recover if we can
		path = find_best_path(name);
		if (path === undefined) {
			console.warn(`find_token_at_path was called with an invalid path: ${path}`);
			return undefined;
		}
	}
	if (name === undefined || name.length < 1) {
		console.warn(`find_token_at_path was called with an invalid name: ${name}`);
		return undefined;
	}
	let folder = convert_path(path);
	if (folder === undefined) {
		console.warn(`find_token_at_path could not find a folder at path ${path}`);
		return undefined;
	}
	if (folder.tokens === undefined) {
		console.warn(`find_token_at_path could not find any tokens at path ${path}`);
		return undefined;
	}
	let token = folder.tokens[name];
	if (token === undefined) {
		console.warn(`find_token_at_path could not find a token with the name ${name} at path ${path}`);
	}
	return token;
}

function save_token_data(tokenData, path, name) {
	let folder = convert_path(path);
	if (folder === undefined) {
		console.warn(`failed to save token data at invalid path ${path}`);
		return;
	}
	if (folder.tokens === undefined) {
		folder.tokens = {};
	}
	folder.tokens[name] = tokenData;
	persist_customtokens();
}

function add_image_to_token_data(imageUrl, path, name) {
	if (imageUrl === undefined || imageUrl.length == 0) {
		return;
	}
	if (path === undefined) {
		path = find_best_path(name);
		if (path === undefined) {
			console.warn(`failed to find token with name ${name} at path ${path}`);
			return;
		}
	}
	let token = find_token_at_path(path, name);
	if (token === undefined) {
		console.warn(`failed to find token with name ${name} at path ${path}`);
		return;
	}
	migrate_token_image_data(token);
	token['data-alternative-images'].push(parse_img(imageUrl));
	save_token_data(token, path, name);
}

function remove_image_from_token_data(path, name, index) {
	if (path == undefined) {
		path = find_best_path(name);
		if (path == undefined) {
			console.warn(`failed to find token with name ${name} at path ${path}`);
			return;
		}
	}
	let token = find_token_at_path(path, name);
	if (token == undefined) {
		console.warn(`failed to find token with name ${name} at path ${path}`);
		return;
	}
	let customImages = token['data-alternative-images'];
	if (customImages == undefined) {
		// user is removing the only image
		token['data-img'] = "";
	} else if (customImages.length > index) {
		let imageBeingRemoved = customImages[index];
		customImages.splice(index, 1);
		token['data-alternative-images'] = customImages;
		if (imageBeingRemoved == token['data-img']) {
			// the user removed the first image. Try to replace it with whatever is first now
			token['data-img'] = customImages.length > 0 ? customImages[0] : "";
		}
	}
	save_token_data(token, path, name);
}

function migrate_token_image_data(token) {
	if (token === undefined) {
		console.warn("migrate_token_image_data called without a token");
		return;
	}

	let dataImg = parse_img(token['data-img']);
	if (dataImg === undefined) {
		// nothing to migrate
		return;
	}

	if (token['data-alternative-images'] === undefined) {
		// it's not set at all so we can just set it to the data-img value
		token['data-alternative-images'] = [ dataImg ];
	} else {
		// let's parse all our urls and make sure they resolve properly before comparing them
		let images = [];
		for (let i = 0; i < token['data-alternative-images'].length; i++) {
			let parsedImage = parse_img(token['data-alternative-images'][i]);
			images.push(parsedImage);
		}
		if (!images.includes(dataImg)) {
			images.unshift(dataImg);
		}
		token['data-alternative-images'] = images;
	}
}

function delete_folder(path) {
	if (path === undefined || path == "" || is_builtin(path)) {
		console.log(`delete_folder called with ${path}`);
		return;
	}
	let parts = path.split("/");
	let folderName = parts.pop();
	let leadingPath = parts.join("/");
	let containingFolder = convert_path(leadingPath);
	delete containingFolder[folderName];
}

function containing_folder_path(path) {
	if (path === undefined || path.length == 0) {
		return "";
	}
	return path.substring(0, path.lastIndexOf("/"));
}
